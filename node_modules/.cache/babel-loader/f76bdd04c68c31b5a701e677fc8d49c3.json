{"ast":null,"code":"import{ZERO_PERCENT,ONE_HUNDRED_PERCENT}from'../constants/misc';// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(tradeA,tradeB){var minimumDelta=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ZERO_PERCENT;if(tradeA&&!tradeB)return false;if(tradeB&&!tradeA)return true;if(!tradeA||!tradeB)return undefined;if(tradeA.tradeType!==tradeB.tradeType||!tradeA.inputAmount.currency.equals(tradeB.inputAmount.currency)||!tradeA.outputAmount.currency.equals(tradeB.outputAmount.currency)){throw new Error('Comparing incomparable trades');}if(minimumDelta.equalTo(ZERO_PERCENT)){return tradeA.executionPrice.lessThan(tradeB.executionPrice);}else{return tradeA.executionPrice.asFraction.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice);}}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/utils/isTradeBetter.ts"],"names":["ZERO_PERCENT","ONE_HUNDRED_PERCENT","isTradeBetter","tradeA","tradeB","minimumDelta","undefined","tradeType","inputAmount","currency","equals","outputAmount","Error","equalTo","executionPrice","lessThan","asFraction","multiply","add"],"mappings":"AAAA,OAASA,YAAT,CAAuBC,mBAAvB,KAAkD,mBAAlD,CAKA;AACA,MAAO,SAASC,CAAAA,aAAT,CACLC,MADK,CAELC,MAFK,CAIgB,IADrBC,CAAAA,YACqB,2DADGL,YACH,CACrB,GAAIG,MAAM,EAAI,CAACC,MAAf,CAAuB,MAAO,MAAP,CACvB,GAAIA,MAAM,EAAI,CAACD,MAAf,CAAuB,MAAO,KAAP,CACvB,GAAI,CAACA,MAAD,EAAW,CAACC,MAAhB,CAAwB,MAAOE,CAAAA,SAAP,CAExB,GACEH,MAAM,CAACI,SAAP,GAAqBH,MAAM,CAACG,SAA5B,EACA,CAACJ,MAAM,CAACK,WAAP,CAAmBC,QAAnB,CAA4BC,MAA5B,CAAmCN,MAAM,CAACI,WAAP,CAAmBC,QAAtD,CADD,EAEA,CAACN,MAAM,CAACQ,YAAP,CAAoBF,QAApB,CAA6BC,MAA7B,CAAoCN,MAAM,CAACO,YAAP,CAAoBF,QAAxD,CAHH,CAIE,CACA,KAAM,IAAIG,CAAAA,KAAJ,CAAU,+BAAV,CAAN,CACD,CAED,GAAIP,YAAY,CAACQ,OAAb,CAAqBb,YAArB,CAAJ,CAAwC,CACtC,MAAOG,CAAAA,MAAM,CAACW,cAAP,CAAsBC,QAAtB,CAA+BX,MAAM,CAACU,cAAtC,CAAP,CACD,CAFD,IAEO,CACL,MAAOX,CAAAA,MAAM,CAACW,cAAP,CAAsBE,UAAtB,CACJC,QADI,CACKZ,YAAY,CAACa,GAAb,CAAiBjB,mBAAjB,CADL,EAEJc,QAFI,CAEKX,MAAM,CAACU,cAFZ,CAAP,CAGD,CACF","sourcesContent":["import { ZERO_PERCENT, ONE_HUNDRED_PERCENT } from '../constants/misc'\nimport { Percent, Currency, TradeType } from '@uniswap/sdk-core'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport { Trade as V3Trade } from '@uniswap/v3-sdk'\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(\n  tradeA: V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType> | undefined | null,\n  tradeB: V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType> | undefined | null,\n  minimumDelta: Percent = ZERO_PERCENT\n): boolean | undefined {\n  if (tradeA && !tradeB) return false\n  if (tradeB && !tradeA) return true\n  if (!tradeA || !tradeB) return undefined\n\n  if (\n    tradeA.tradeType !== tradeB.tradeType ||\n    !tradeA.inputAmount.currency.equals(tradeB.inputAmount.currency) ||\n    !tradeA.outputAmount.currency.equals(tradeB.outputAmount.currency)\n  ) {\n    throw new Error('Comparing incomparable trades')\n  }\n\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice)\n  } else {\n    return tradeA.executionPrice.asFraction\n      .multiply(minimumDelta.add(ONE_HUNDRED_PERCENT))\n      .lessThan(tradeB.executionPrice)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}