{"ast":null,"code":"import _slicedToArray from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{Trade}from'@uniswap/v2-sdk';import{useMemo}from'react';import{isTradeBetter}from'utils/isTradeBetter';import{BETTER_TRADE_LESS_HOPS_THRESHOLD}from'../constants/misc';import{useAllCurrencyCombinations}from'./useAllCurrencyCombinations';import{PairState,useV2Pairs}from'./useV2Pairs';function useAllCommonPairs(currencyA,currencyB){var allCurrencyCombinations=useAllCurrencyCombinations(currencyA,currencyB);var allPairs=useV2Pairs(allCurrencyCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(function(){return Object.values(allPairs// filter out invalid pairs\n.filter(function(result){return Boolean(result[0]===PairState.EXISTS&&result[1]);})// filter out duplicated pairs\n.reduce(function(memo,_ref){var _memo$curr$liquidityT;var _ref2=_slicedToArray(_ref,2),curr=_ref2[1];memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{}));},[allPairs]);}var MAX_HOPS=3;/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useV2TradeExactIn(currencyAmountIn,currencyOut){var _ref3=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref3$maxHops=_ref3.maxHops,maxHops=_ref3$maxHops===void 0?MAX_HOPS:_ref3$maxHops;var allowedPairs=useAllCommonPairs(currencyAmountIn===null||currencyAmountIn===void 0?void 0:currencyAmountIn.currency,currencyOut);return useMemo(function(){if(currencyAmountIn&&currencyOut&&allowedPairs.length>0){if(maxHops===1){var _Trade$bestTradeExact;return(_Trade$bestTradeExact=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact!==void 0?_Trade$bestTradeExact:null;}// search through trades with varying hops, find best trade out of them\nvar bestTradeSoFar=null;for(var i=1;i<=maxHops;i++){var _Trade$bestTradeExact2;var currentTrade=(_Trade$bestTradeExact2=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact2!==void 0?_Trade$bestTradeExact2:null;// if current trade is best yet, save it\nif(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[allowedPairs,currencyAmountIn,currencyOut,maxHops]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useV2TradeExactOut(currencyIn,currencyAmountOut){var _ref4=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref4$maxHops=_ref4.maxHops,maxHops=_ref4$maxHops===void 0?MAX_HOPS:_ref4$maxHops;var allowedPairs=useAllCommonPairs(currencyIn,currencyAmountOut===null||currencyAmountOut===void 0?void 0:currencyAmountOut.currency);return useMemo(function(){if(currencyIn&&currencyAmountOut&&allowedPairs.length>0){if(maxHops===1){var _Trade$bestTradeExact3;return(_Trade$bestTradeExact3=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact3!==void 0?_Trade$bestTradeExact3:null;}// search through trades with varying hops, find best trade out of them\nvar bestTradeSoFar=null;for(var i=1;i<=maxHops;i++){var _Trade$bestTradeExact4;var currentTrade=(_Trade$bestTradeExact4=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact4!==void 0?_Trade$bestTradeExact4:null;if(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[currencyIn,currencyAmountOut,allowedPairs,maxHops]);}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/hooks/useV2Trade.ts"],"names":["Trade","useMemo","isTradeBetter","BETTER_TRADE_LESS_HOPS_THRESHOLD","useAllCurrencyCombinations","PairState","useV2Pairs","useAllCommonPairs","currencyA","currencyB","allCurrencyCombinations","allPairs","Object","values","filter","result","Boolean","EXISTS","reduce","memo","curr","liquidityToken","address","MAX_HOPS","useV2TradeExactIn","currencyAmountIn","currencyOut","maxHops","allowedPairs","currency","length","bestTradeExactIn","maxNumResults","bestTradeSoFar","i","currentTrade","useV2TradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Trade } from '@uniswap/v2-sdk'\nimport { useMemo } from 'react'\nimport { isTradeBetter } from 'utils/isTradeBetter'\nimport { BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants/misc'\nimport { useAllCurrencyCombinations } from './useAllCurrencyCombinations'\nimport { PairState, useV2Pairs } from './useV2Pairs'\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const allCurrencyCombinations = useAllCurrencyCombinations(currencyA, currencyB)\n\n  const allPairs = useV2Pairs(allCurrencyCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\nconst MAX_HOPS = 3\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useV2TradeExactIn(\n  currencyAmountIn?: CurrencyAmount<Currency>,\n  currencyOut?: Currency,\n  { maxHops = MAX_HOPS } = {}\n): Trade<Currency, Currency, TradeType.EXACT_INPUT> | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (maxHops === 1) {\n        return (\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade<Currency, Currency, TradeType.EXACT_INPUT> | null = null\n      for (let i = 1; i <= maxHops; i++) {\n        const currentTrade: Trade<Currency, Currency, TradeType.EXACT_INPUT> | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut, maxHops])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useV2TradeExactOut(\n  currencyIn?: Currency,\n  currencyAmountOut?: CurrencyAmount<Currency>,\n  { maxHops = MAX_HOPS } = {}\n): Trade<Currency, Currency, TradeType.EXACT_OUTPUT> | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (maxHops === 1) {\n        return (\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade<Currency, Currency, TradeType.EXACT_OUTPUT> | null = null\n      for (let i = 1; i <= maxHops; i++) {\n        const currentTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n    return null\n  }, [currencyIn, currencyAmountOut, allowedPairs, maxHops])\n}\n"]},"metadata":{},"sourceType":"module"}