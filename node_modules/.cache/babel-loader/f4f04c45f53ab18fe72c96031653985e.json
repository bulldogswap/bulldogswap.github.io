{"ast":null,"code":"import{getAddress}from'@ethersproject/address';import{AddressZero}from'@ethersproject/constants';import{Contract}from'@ethersproject/contracts';// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value){try{return getAddress(value);}catch(_unused){return false;}}// shorten the checksummed version of the input address to have 0x + 4 characters at start and end\nexport function shortenAddress(address){var chars=arguments.length>1&&arguments[1]!==undefined?arguments[1]:4;var parsed=isAddress(address);if(!parsed){throw Error(\"Invalid 'address' parameter '\".concat(address,\"'.\"));}return\"\".concat(parsed.substring(0,chars+2),\"...\").concat(parsed.substring(42-chars));}// account is not optional\nfunction getSigner(library,account){return library.getSigner(account).connectUnchecked();}// account is optional\nfunction getProviderOrSigner(library,account){return account?getSigner(library,account):library;}// account is optional\nexport function getContract(address,ABI,library,account){if(!isAddress(address)||address===AddressZero){throw Error(\"Invalid 'address' parameter '\".concat(address,\"'.\"));}return new Contract(address,ABI,getProviderOrSigner(library,account));}export function escapeRegExp(string){return string.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&');// $& means the whole matched string\n}export function isTokenOnList(tokenAddressMap,token){var _tokenAddressMap$toke;return Boolean((token===null||token===void 0?void 0:token.isToken)&&((_tokenAddressMap$toke=tokenAddressMap[token.chainId])===null||_tokenAddressMap$toke===void 0?void 0:_tokenAddressMap$toke[token.address]));}export function formattedFeeAmount(feeAmount){return feeAmount/10000;}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/utils/index.ts"],"names":["getAddress","AddressZero","Contract","isAddress","value","shortenAddress","address","chars","parsed","Error","substring","getSigner","library","account","connectUnchecked","getProviderOrSigner","getContract","ABI","escapeRegExp","string","replace","isTokenOnList","tokenAddressMap","token","Boolean","isToken","chainId","formattedFeeAmount","feeAmount"],"mappings":"AAAA,OAASA,UAAT,KAA2B,wBAA3B,CACA,OAASC,WAAT,KAA4B,0BAA5B,CACA,OAASC,QAAT,KAAyB,0BAAzB,CAMA;AACA,MAAO,SAASC,CAAAA,SAAT,CAAmBC,KAAnB,CAA+C,CACpD,GAAI,CACF,MAAOJ,CAAAA,UAAU,CAACI,KAAD,CAAjB,CACD,CAAC,cAAM,CACN,MAAO,MAAP,CACD,CACF,CAED;AACA,MAAO,SAASC,CAAAA,cAAT,CAAwBC,OAAxB,CAA4D,IAAnBC,CAAAA,KAAmB,2DAAX,CAAW,CACjE,GAAMC,CAAAA,MAAM,CAAGL,SAAS,CAACG,OAAD,CAAxB,CACA,GAAI,CAACE,MAAL,CAAa,CACX,KAAMC,CAAAA,KAAK,wCAAiCH,OAAjC,OAAX,CACD,CACD,gBAAUE,MAAM,CAACE,SAAP,CAAiB,CAAjB,CAAoBH,KAAK,CAAG,CAA5B,CAAV,eAA8CC,MAAM,CAACE,SAAP,CAAiB,GAAKH,KAAtB,CAA9C,EACD,CAED;AACA,QAASI,CAAAA,SAAT,CAAmBC,OAAnB,CAA0CC,OAA1C,CAA0E,CACxE,MAAOD,CAAAA,OAAO,CAACD,SAAR,CAAkBE,OAAlB,EAA2BC,gBAA3B,EAAP,CACD,CAED;AACA,QAASC,CAAAA,mBAAT,CAA6BH,OAA7B,CAAoDC,OAApD,CAAoG,CAClG,MAAOA,CAAAA,OAAO,CAAGF,SAAS,CAACC,OAAD,CAAUC,OAAV,CAAZ,CAAiCD,OAA/C,CACD,CAED;AACA,MAAO,SAASI,CAAAA,WAAT,CAAqBV,OAArB,CAAsCW,GAAtC,CAAgDL,OAAhD,CAAuEC,OAAvE,CAAmG,CACxG,GAAI,CAACV,SAAS,CAACG,OAAD,CAAV,EAAuBA,OAAO,GAAKL,WAAvC,CAAoD,CAClD,KAAMQ,CAAAA,KAAK,wCAAiCH,OAAjC,OAAX,CACD,CAED,MAAO,IAAIJ,CAAAA,QAAJ,CAAaI,OAAb,CAAsBW,GAAtB,CAA2BF,mBAAmB,CAACH,OAAD,CAAUC,OAAV,CAA9C,CAAP,CACD,CAED,MAAO,SAASK,CAAAA,YAAT,CAAsBC,MAAtB,CAA8C,CACnD,MAAOA,CAAAA,MAAM,CAACC,OAAP,CAAe,qBAAf,CAAsC,MAAtC,CAAP,CAAqD;AACtD,CAED,MAAO,SAASC,CAAAA,aAAT,CAAuBC,eAAvB,CAAyDC,KAAzD,CAAiF,2BACtF,MAAOC,CAAAA,OAAO,CAAC,CAAAD,KAAK,OAAL,EAAAA,KAAK,SAAL,QAAAA,KAAK,CAAEE,OAAP,2BAAkBH,eAAe,CAACC,KAAK,CAACG,OAAP,CAAjC,gDAAkB,sBAAiCH,KAAK,CAACjB,OAAvC,CAAlB,CAAD,CAAd,CACD,CAED,MAAO,SAASqB,CAAAA,kBAAT,CAA4BC,SAA5B,CAA0D,CAC/D,MAAOA,CAAAA,SAAS,CAAG,KAAnB,CACD","sourcesContent":["import { getAddress } from '@ethersproject/address'\nimport { AddressZero } from '@ethersproject/constants'\nimport { Contract } from '@ethersproject/contracts'\nimport { JsonRpcSigner, Web3Provider } from '@ethersproject/providers'\nimport { Token } from '@uniswap/sdk-core'\nimport { FeeAmount } from '@uniswap/v3-sdk/dist/'\nimport { TokenAddressMap } from '../state/lists/hooks'\n\n// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value: any): string | false {\n  try {\n    return getAddress(value)\n  } catch {\n    return false\n  }\n}\n\n// shorten the checksummed version of the input address to have 0x + 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  const parsed = isAddress(address)\n  if (!parsed) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n  return `${parsed.substring(0, chars + 2)}...${parsed.substring(42 - chars)}`\n}\n\n// account is not optional\nfunction getSigner(library: Web3Provider, account: string): JsonRpcSigner {\n  return library.getSigner(account).connectUnchecked()\n}\n\n// account is optional\nfunction getProviderOrSigner(library: Web3Provider, account?: string): Web3Provider | JsonRpcSigner {\n  return account ? getSigner(library, account) : library\n}\n\n// account is optional\nexport function getContract(address: string, ABI: any, library: Web3Provider, account?: string): Contract {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n\n  return new Contract(address, ABI, getProviderOrSigner(library, account) as any)\n}\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n}\n\nexport function isTokenOnList(tokenAddressMap: TokenAddressMap, token?: Token): boolean {\n  return Boolean(token?.isToken && tokenAddressMap[token.chainId]?.[token.address])\n}\n\nexport function formattedFeeAmount(feeAmount: FeeAmount): number {\n  return feeAmount / 10000\n}\n"]},"metadata":{},"sourceType":"module"}