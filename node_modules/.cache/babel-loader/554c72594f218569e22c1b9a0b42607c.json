{"ast":null,"code":"import _objectSpread from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{tickToPrice}from'@uniswap/v3-sdk';import JSBI from'jsbi';var PRICE_FIXED_DIGITS=8;// Computes the numSurroundingTicks above or below the active tick.\nexport default function computeSurroundingTicks(token0,token1,activeTickProcessed,sortedTickData,pivot,ascending){var previousTickProcessed=_objectSpread({},activeTickProcessed);// Iterate outwards (either up or down depending on direction) from the active tick,\n// building active liquidity for every tick.\nvar processedTicks=[];for(var i=pivot+(ascending?1:-1);ascending?i<sortedTickData.length:i>=0;ascending?i++:i--){var tickIdx=Number(sortedTickData[i].tickIdx);var currentTickProcessed={liquidityActive:previousTickProcessed.liquidityActive,tickIdx:tickIdx,liquidityNet:JSBI.BigInt(sortedTickData[i].liquidityNet),price0:tickToPrice(token0,token1,tickIdx).toFixed(PRICE_FIXED_DIGITS)};// Update the active liquidity.\n// If we are iterating ascending and we found an initialized tick we immediately apply\n// it to the current processed tick we are building.\n// If we are iterating descending, we don't want to apply the net liquidity until the following tick.\nif(ascending){currentTickProcessed.liquidityActive=JSBI.add(previousTickProcessed.liquidityActive,JSBI.BigInt(sortedTickData[i].liquidityNet));}else if(!ascending&&JSBI.notEqual(previousTickProcessed.liquidityNet,JSBI.BigInt(0))){// We are iterating descending, so look at the previous tick and apply any net liquidity.\ncurrentTickProcessed.liquidityActive=JSBI.subtract(previousTickProcessed.liquidityActive,previousTickProcessed.liquidityNet);}processedTicks.push(currentTickProcessed);previousTickProcessed=currentTickProcessed;}if(!ascending){processedTicks=processedTicks.reverse();}return processedTicks;}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/utils/computeSurroundingTicks.ts"],"names":["tickToPrice","JSBI","PRICE_FIXED_DIGITS","computeSurroundingTicks","token0","token1","activeTickProcessed","sortedTickData","pivot","ascending","previousTickProcessed","processedTicks","i","length","tickIdx","Number","currentTickProcessed","liquidityActive","liquidityNet","BigInt","price0","toFixed","add","notEqual","subtract","push","reverse"],"mappings":"uLACA,OAASA,WAAT,KAA4B,iBAA5B,CAEA,MAAOC,CAAAA,IAAP,KAAiB,MAAjB,CAGA,GAAMC,CAAAA,kBAAkB,CAAG,CAA3B,CAEA;AACA,cAAe,SAASC,CAAAA,uBAAT,CACbC,MADa,CAEbC,MAFa,CAGbC,mBAHa,CAIbC,cAJa,CAKbC,KALa,CAMbC,SANa,CAOI,CACjB,GAAIC,CAAAA,qBAAoC,kBACnCJ,mBADmC,CAAxC,CAGA;AACA;AACA,GAAIK,CAAAA,cAA+B,CAAG,EAAtC,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAGJ,KAAK,EAAIC,SAAS,CAAG,CAAH,CAAO,CAAC,CAArB,CAAlB,CAA2CA,SAAS,CAAGG,CAAC,CAAGL,cAAc,CAACM,MAAtB,CAA+BD,CAAC,EAAI,CAAxF,CAA2FH,SAAS,CAAGG,CAAC,EAAJ,CAASA,CAAC,EAA9G,CAAkH,CAChH,GAAME,CAAAA,OAAO,CAAGC,MAAM,CAACR,cAAc,CAACK,CAAD,CAAd,CAAkBE,OAAnB,CAAtB,CACA,GAAME,CAAAA,oBAAmC,CAAG,CAC1CC,eAAe,CAAEP,qBAAqB,CAACO,eADG,CAE1CH,OAAO,CAAPA,OAF0C,CAG1CI,YAAY,CAAEjB,IAAI,CAACkB,MAAL,CAAYZ,cAAc,CAACK,CAAD,CAAd,CAAkBM,YAA9B,CAH4B,CAI1CE,MAAM,CAAEpB,WAAW,CAACI,MAAD,CAASC,MAAT,CAAiBS,OAAjB,CAAX,CAAqCO,OAArC,CAA6CnB,kBAA7C,CAJkC,CAA5C,CAOA;AACA;AACA;AACA;AACA,GAAIO,SAAJ,CAAe,CACbO,oBAAoB,CAACC,eAArB,CAAuChB,IAAI,CAACqB,GAAL,CACrCZ,qBAAqB,CAACO,eADe,CAErChB,IAAI,CAACkB,MAAL,CAAYZ,cAAc,CAACK,CAAD,CAAd,CAAkBM,YAA9B,CAFqC,CAAvC,CAID,CALD,IAKO,IAAI,CAACT,SAAD,EAAcR,IAAI,CAACsB,QAAL,CAAcb,qBAAqB,CAACQ,YAApC,CAAkDjB,IAAI,CAACkB,MAAL,CAAY,CAAZ,CAAlD,CAAlB,CAAqF,CAC1F;AACAH,oBAAoB,CAACC,eAArB,CAAuChB,IAAI,CAACuB,QAAL,CACrCd,qBAAqB,CAACO,eADe,CAErCP,qBAAqB,CAACQ,YAFe,CAAvC,CAID,CAEDP,cAAc,CAACc,IAAf,CAAoBT,oBAApB,EACAN,qBAAqB,CAAGM,oBAAxB,CACD,CAED,GAAI,CAACP,SAAL,CAAgB,CACdE,cAAc,CAAGA,cAAc,CAACe,OAAf,EAAjB,CACD,CAED,MAAOf,CAAAA,cAAP,CACD","sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { tickToPrice } from '@uniswap/v3-sdk'\nimport { TickProcessed } from 'hooks/usePoolTickData'\nimport JSBI from 'jsbi'\nimport { AllV3TicksQuery } from 'state/data/generated'\n\nconst PRICE_FIXED_DIGITS = 8\n\n// Computes the numSurroundingTicks above or below the active tick.\nexport default function computeSurroundingTicks(\n  token0: Token,\n  token1: Token,\n  activeTickProcessed: TickProcessed,\n  sortedTickData: AllV3TicksQuery['ticks'],\n  pivot: number,\n  ascending: boolean\n): TickProcessed[] {\n  let previousTickProcessed: TickProcessed = {\n    ...activeTickProcessed,\n  }\n  // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n  let processedTicks: TickProcessed[] = []\n  for (let i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    const tickIdx = Number(sortedTickData[i].tickIdx)\n    const currentTickProcessed: TickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tickIdx,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tickIdx).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(\n        previousTickProcessed.liquidityActive,\n        JSBI.BigInt(sortedTickData[i].liquidityNet)\n      )\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(\n        previousTickProcessed.liquidityActive,\n        previousTickProcessed.liquidityNet\n      )\n    }\n\n    processedTicks.push(currentTickProcessed)\n    previousTickProcessed = currentTickProcessed\n  }\n\n  if (!ascending) {\n    processedTicks = processedTicks.reverse()\n  }\n\n  return processedTicks\n}\n"]},"metadata":{},"sourceType":"module"}