{"ast":null,"code":"import _regeneratorRuntime from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{useEffect,useMemo,useRef}from'react';import{useActiveWeb3React}from'../../hooks/web3';import{useMulticall2Contract}from'../../hooks/useContract';import useDebounce from'../../hooks/useDebounce';import chunkArray from'../../utils/chunkArray';import{retry,RetryableError}from'../../utils/retry';import{useBlockNumber}from'../application/hooks';import{errorFetchingMulticallResults,fetchingMulticallResults,updateMulticallResults}from'./actions';import{useAppDispatch,useAppSelector}from'state/hooks';import{parseCallKey}from'./utils';var DEFAULT_GAS_REQUIRED=1000000;/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicall multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param blockNumber block number passed as the block tag in the eth_call\n */function fetchChunk(_x,_x2,_x3){return _fetchChunk.apply(this,arguments);}/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */function _fetchChunk(){_fetchChunk=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(multicall,chunk,blockNumber){var _yield$multicall$call,returnData,_error$message;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:console.debug('Fetching chunk',chunk,blockNumber);_context.prev=1;_context.next=4;return multicall.callStatic.multicall(chunk.map(function(obj){var _obj$gasRequired;return{target:obj.address,callData:obj.callData,gasLimit:(_obj$gasRequired=obj.gasRequired)!==null&&_obj$gasRequired!==void 0?_obj$gasRequired:DEFAULT_GAS_REQUIRED};}),{blockTag:blockNumber});case 4:_yield$multicall$call=_context.sent;returnData=_yield$multicall$call.returnData;if(process.env.NODE_ENV==='development'){returnData.forEach(function(_ref,i){var _chunk$i$gasRequired;var gasUsed=_ref.gasUsed,returnData=_ref.returnData,success=_ref.success;if(!success&&returnData.length===2&&gasUsed.gte(Math.floor(((_chunk$i$gasRequired=chunk[i].gasRequired)!==null&&_chunk$i$gasRequired!==void 0?_chunk$i$gasRequired:DEFAULT_GAS_REQUIRED)*0.95))){var _chunk$i$gasRequired2;console.warn(\"A call failed due to requiring \".concat(gasUsed.toString(),\" vs. allowed \").concat((_chunk$i$gasRequired2=chunk[i].gasRequired)!==null&&_chunk$i$gasRequired2!==void 0?_chunk$i$gasRequired2:DEFAULT_GAS_REQUIRED),chunk[i]);}});}return _context.abrupt(\"return\",returnData);case 10:_context.prev=10;_context.t0=_context[\"catch\"](1);if(!(_context.t0.code===-32000||((_error$message=_context.t0.message)===null||_error$message===void 0?void 0:_error$message.indexOf('header not found'))!==-1)){_context.next=14;break;}throw new RetryableError(\"header not found for block number \".concat(blockNumber));case 14:console.error('Failed to fetch chunk',_context.t0);throw _context.t0;case 16:case\"end\":return _context.stop();}}},_callee,null,[[1,10]]);}));return _fetchChunk.apply(this,arguments);}export function activeListeningKeys(allListeners,chainId){if(!allListeners||!chainId)return{};var listeners=allListeners[chainId];if(!listeners)return{};return Object.keys(listeners).reduce(function(memo,callKey){var keyListeners=listeners[callKey];memo[callKey]=Object.keys(keyListeners).filter(function(key){var blocksPerFetch=parseInt(key);if(blocksPerFetch<=0)return false;return keyListeners[blocksPerFetch]>0;}).reduce(function(previousMin,current){return Math.min(previousMin,parseInt(current));},Infinity);return memo;},{});}/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */export function outdatedListeningKeys(callResults,listeningKeys,chainId,latestBlockNumber){if(!chainId||!latestBlockNumber)return[];var results=callResults[chainId];// no results at all, load everything\nif(!results)return Object.keys(listeningKeys);return Object.keys(listeningKeys).filter(function(callKey){var blocksPerFetch=listeningKeys[callKey];var data=callResults[chainId][callKey];// no data, must fetch\nif(!data)return true;var minDataBlockNumber=latestBlockNumber-(blocksPerFetch-1);// already fetching it for a recent enough block, don't refetch it\nif(data.fetchingBlockNumber&&data.fetchingBlockNumber>=minDataBlockNumber)return false;// if data is older than minDataBlockNumber, fetch it\nreturn!data.blockNumber||data.blockNumber<minDataBlockNumber;});}export default function Updater(){var dispatch=useAppDispatch();var state=useAppSelector(function(state){return state.multicall;});// wait for listeners to settle before triggering updates\nvar debouncedListeners=useDebounce(state.callListeners,100);var latestBlockNumber=useBlockNumber();var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var multicall2Contract=useMulticall2Contract();var cancellations=useRef();var listeningKeys=useMemo(function(){return activeListeningKeys(debouncedListeners,chainId);},[debouncedListeners,chainId]);var unserializedOutdatedCallKeys=useMemo(function(){return outdatedListeningKeys(state.callResults,listeningKeys,chainId,latestBlockNumber);},[chainId,state.callResults,listeningKeys,latestBlockNumber]);var serializedOutdatedCallKeys=useMemo(function(){return JSON.stringify(unserializedOutdatedCallKeys.sort());},[unserializedOutdatedCallKeys]);useEffect(function(){if(!latestBlockNumber||!chainId||!multicall2Contract)return;var outdatedCallKeys=JSON.parse(serializedOutdatedCallKeys);if(outdatedCallKeys.length===0)return;var calls=outdatedCallKeys.map(function(key){return parseCallKey(key);});var chunkedCalls=chunkArray(calls);if(cancellations.current&&cancellations.current.blockNumber!==latestBlockNumber){cancellations.current.cancellations.forEach(function(c){return c();});}dispatch(fetchingMulticallResults({calls:calls,chainId:chainId,fetchingBlockNumber:latestBlockNumber}));cancellations.current={blockNumber:latestBlockNumber,cancellations:chunkedCalls.map(function(chunk,index){var _retry=retry(function(){return fetchChunk(multicall2Contract,chunk,latestBlockNumber);},{n:Infinity,minWait:1000,maxWait:2500}),cancel=_retry.cancel,promise=_retry.promise;promise.then(function(returnData){// accumulates the length of all previous indices\nvar firstCallKeyIndex=chunkedCalls.slice(0,index).reduce(function(memo,curr){return memo+curr.length;},0);var lastCallKeyIndex=firstCallKeyIndex+returnData.length;var slice=outdatedCallKeys.slice(firstCallKeyIndex,lastCallKeyIndex);// split the returned slice into errors and success\nvar _slice$reduce=slice.reduce(function(memo,callKey,i){if(returnData[i].success){var _returnData$i$returnD;memo.results[callKey]=(_returnData$i$returnD=returnData[i].returnData)!==null&&_returnData$i$returnD!==void 0?_returnData$i$returnD:null;}else{memo.erroredCalls.push(parseCallKey(callKey));}return memo;},{erroredCalls:[],results:{}}),erroredCalls=_slice$reduce.erroredCalls,results=_slice$reduce.results;// dispatch any new results\nif(Object.keys(results).length>0)dispatch(updateMulticallResults({chainId:chainId,results:results,blockNumber:latestBlockNumber}));// dispatch any errored calls\nif(erroredCalls.length>0){console.debug('Calls errored in fetch',erroredCalls);dispatch(errorFetchingMulticallResults({calls:erroredCalls,chainId:chainId,fetchingBlockNumber:latestBlockNumber}));}}).catch(function(error){if(error.isCancelledError){console.debug('Cancelled fetch for blockNumber',latestBlockNumber,chunk,chainId);return;}console.error('Failed to fetch multicall chunk',chunk,chainId,error);dispatch(errorFetchingMulticallResults({calls:chunk,chainId:chainId,fetchingBlockNumber:latestBlockNumber}));});return cancel;})};},[chainId,multicall2Contract,dispatch,serializedOutdatedCallKeys,latestBlockNumber]);return null;}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/state/multicall/updater.tsx"],"names":["useEffect","useMemo","useRef","useActiveWeb3React","useMulticall2Contract","useDebounce","chunkArray","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","updateMulticallResults","useAppDispatch","useAppSelector","parseCallKey","DEFAULT_GAS_REQUIRED","fetchChunk","multicall","chunk","blockNumber","console","debug","callStatic","map","obj","target","address","callData","gasLimit","gasRequired","blockTag","returnData","process","env","NODE_ENV","forEach","i","gasUsed","success","length","gte","Math","floor","warn","toString","code","message","indexOf","error","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","results","data","minDataBlockNumber","fetchingBlockNumber","Updater","dispatch","state","debouncedListeners","callListeners","multicall2Contract","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","outdatedCallKeys","parse","calls","chunkedCalls","c","index","n","minWait","maxWait","cancel","promise","then","firstCallKeyIndex","slice","curr","lastCallKeyIndex","erroredCalls","push","catch","isCancelledError"],"mappings":"6WAAA,OAASA,SAAT,CAAoBC,OAApB,CAA6BC,MAA7B,KAA2C,OAA3C,CACA,OAASC,kBAAT,KAAmC,kBAAnC,CACA,OAASC,qBAAT,KAAsC,yBAAtC,CACA,MAAOC,CAAAA,WAAP,KAAwB,yBAAxB,CACA,MAAOC,CAAAA,UAAP,KAAuB,wBAAvB,CACA,OAASC,KAAT,CAAgBC,cAAhB,KAAsC,mBAAtC,CACA,OAASC,cAAT,KAA+B,sBAA/B,CAEA,OAASC,6BAAT,CAAwCC,wBAAxC,CAAkEC,sBAAlE,KAAgG,WAAhG,CACA,OAASC,cAAT,CAAyBC,cAAzB,KAA+C,aAA/C,CACA,OAAeC,YAAf,KAAmC,SAAnC,CAGA,GAAMC,CAAAA,oBAAoB,CAAG,OAA7B,CAEA;AACA;AACA;AACA;AACA;AACA,G,QACeC,CAAAA,U,uDA2Cf;AACA;AACA;AACA;AACA;AACA,G,2FAhDA,iBACEC,SADF,CAEEC,KAFF,CAGEC,WAHF,sKAKEC,OAAO,CAACC,KAAR,CAAc,gBAAd,CAAgCH,KAAhC,CAAuCC,WAAvC,EALF,sCAOiCF,CAAAA,SAAS,CAACK,UAAV,CAAqBL,SAArB,CAC3BC,KAAK,CAACK,GAAN,CAAU,SAACC,GAAD,6BAAU,CAClBC,MAAM,CAAED,GAAG,CAACE,OADM,CAElBC,QAAQ,CAAEH,GAAG,CAACG,QAFI,CAGlBC,QAAQ,mBAAEJ,GAAG,CAACK,WAAN,qDAAqBd,oBAHX,CAAV,EAAV,CAD2B,CAM3B,CAAEe,QAAQ,CAAEX,WAAZ,CAN2B,CAPjC,4CAOYY,UAPZ,uBAOYA,UAPZ,CAgBI,GAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,aAA7B,CAA4C,CAC1CH,UAAU,CAACI,OAAX,CAAmB,cAAmCC,CAAnC,CAAyC,6BAAtCC,CAAAA,OAAsC,MAAtCA,OAAsC,CAA7BN,UAA6B,MAA7BA,UAA6B,CAAjBO,OAAiB,MAAjBA,OAAiB,CAC1D,GACE,CAACA,OAAD,EACAP,UAAU,CAACQ,MAAX,GAAsB,CADtB,EAEAF,OAAO,CAACG,GAAR,CAAYC,IAAI,CAACC,KAAL,CAAW,uBAACxB,KAAK,CAACkB,CAAD,CAAL,CAASP,WAAV,6DAAyBd,oBAAzB,EAAiD,IAA5D,CAAZ,CAHF,CAIE,2BACAK,OAAO,CAACuB,IAAR,0CACoCN,OAAO,CAACO,QAAR,EADpC,gDAEI1B,KAAK,CAACkB,CAAD,CAAL,CAASP,WAFb,+DAE4Bd,oBAF5B,EAIEG,KAAK,CAACkB,CAAD,CAJP,EAMD,CACF,CAbD,EAcD,CA/BL,gCAiCWL,UAjCX,iEAmCQ,YAAMc,IAAN,GAAe,CAAC,KAAhB,EAAyB,6BAAMC,OAAN,wDAAeC,OAAf,CAAuB,kBAAvB,KAA+C,CAAC,CAnCjF,gCAoCY,IAAIxC,CAAAA,cAAJ,6CAAwDY,WAAxD,EApCZ,SAsCIC,OAAO,CAAC4B,KAAR,CAAc,uBAAd,cAtCJ,uF,6CAiDA,MAAO,SAASC,CAAAA,mBAAT,CACLC,YADK,CAELC,OAFK,CAG0B,CAC/B,GAAI,CAACD,YAAD,EAAiB,CAACC,OAAtB,CAA+B,MAAO,EAAP,CAC/B,GAAMC,CAAAA,SAAS,CAAGF,YAAY,CAACC,OAAD,CAA9B,CACA,GAAI,CAACC,SAAL,CAAgB,MAAO,EAAP,CAEhB,MAAOC,CAAAA,MAAM,CAACC,IAAP,CAAYF,SAAZ,EAAuBG,MAAvB,CAA6D,SAACC,IAAD,CAAOC,OAAP,CAAmB,CACrF,GAAMC,CAAAA,YAAY,CAAGN,SAAS,CAACK,OAAD,CAA9B,CAEAD,IAAI,CAACC,OAAD,CAAJ,CAAgBJ,MAAM,CAACC,IAAP,CAAYI,YAAZ,EACbC,MADa,CACN,SAACC,GAAD,CAAS,CACf,GAAMC,CAAAA,cAAc,CAAGC,QAAQ,CAACF,GAAD,CAA/B,CACA,GAAIC,cAAc,EAAI,CAAtB,CAAyB,MAAO,MAAP,CACzB,MAAOH,CAAAA,YAAY,CAACG,cAAD,CAAZ,CAA+B,CAAtC,CACD,CALa,EAMbN,MANa,CAMN,SAACQ,WAAD,CAAcC,OAAd,CAA0B,CAChC,MAAOvB,CAAAA,IAAI,CAACwB,GAAL,CAASF,WAAT,CAAsBD,QAAQ,CAACE,OAAD,CAA9B,CAAP,CACD,CARa,CAQXE,QARW,CAAhB,CASA,MAAOV,CAAAA,IAAP,CACD,CAbM,CAaJ,EAbI,CAAP,CAcD,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASW,CAAAA,qBAAT,CACLC,WADK,CAELC,aAFK,CAGLlB,OAHK,CAILmB,iBAJK,CAKK,CACV,GAAI,CAACnB,OAAD,EAAY,CAACmB,iBAAjB,CAAoC,MAAO,EAAP,CACpC,GAAMC,CAAAA,OAAO,CAAGH,WAAW,CAACjB,OAAD,CAA3B,CACA;AACA,GAAI,CAACoB,OAAL,CAAc,MAAOlB,CAAAA,MAAM,CAACC,IAAP,CAAYe,aAAZ,CAAP,CAEd,MAAOhB,CAAAA,MAAM,CAACC,IAAP,CAAYe,aAAZ,EAA2BV,MAA3B,CAAkC,SAACF,OAAD,CAAa,CACpD,GAAMI,CAAAA,cAAc,CAAGQ,aAAa,CAACZ,OAAD,CAApC,CAEA,GAAMe,CAAAA,IAAI,CAAGJ,WAAW,CAACjB,OAAD,CAAX,CAAqBM,OAArB,CAAb,CACA;AACA,GAAI,CAACe,IAAL,CAAW,MAAO,KAAP,CAEX,GAAMC,CAAAA,kBAAkB,CAAGH,iBAAiB,EAAIT,cAAc,CAAG,CAArB,CAA5C,CAEA;AACA,GAAIW,IAAI,CAACE,mBAAL,EAA4BF,IAAI,CAACE,mBAAL,EAA4BD,kBAA5D,CAAgF,MAAO,MAAP,CAEhF;AACA,MAAO,CAACD,IAAI,CAACrD,WAAN,EAAqBqD,IAAI,CAACrD,WAAL,CAAmBsD,kBAA/C,CACD,CAdM,CAAP,CAeD,CAED,cAAe,SAASE,CAAAA,OAAT,EAAyB,CACtC,GAAMC,CAAAA,QAAQ,CAAGhE,cAAc,EAA/B,CACA,GAAMiE,CAAAA,KAAK,CAAGhE,cAAc,CAAC,SAACgE,KAAD,QAAWA,CAAAA,KAAK,CAAC5D,SAAjB,EAAD,CAA5B,CACA;AACA,GAAM6D,CAAAA,kBAAkB,CAAG1E,WAAW,CAACyE,KAAK,CAACE,aAAP,CAAsB,GAAtB,CAAtC,CACA,GAAMT,CAAAA,iBAAiB,CAAG9D,cAAc,EAAxC,CACA,wBAAoBN,kBAAkB,EAAtC,CAAQiD,OAAR,qBAAQA,OAAR,CACA,GAAM6B,CAAAA,kBAAkB,CAAG7E,qBAAqB,EAAhD,CACA,GAAM8E,CAAAA,aAAa,CAAGhF,MAAM,EAA5B,CAEA,GAAMoE,CAAAA,aAA4C,CAAGrE,OAAO,CAAC,UAAM,CACjE,MAAOiD,CAAAA,mBAAmB,CAAC6B,kBAAD,CAAqB3B,OAArB,CAA1B,CACD,CAF2D,CAEzD,CAAC2B,kBAAD,CAAqB3B,OAArB,CAFyD,CAA5D,CAIA,GAAM+B,CAAAA,4BAA4B,CAAGlF,OAAO,CAAC,UAAM,CACjD,MAAOmE,CAAAA,qBAAqB,CAACU,KAAK,CAACT,WAAP,CAAoBC,aAApB,CAAmClB,OAAnC,CAA4CmB,iBAA5C,CAA5B,CACD,CAF2C,CAEzC,CAACnB,OAAD,CAAU0B,KAAK,CAACT,WAAhB,CAA6BC,aAA7B,CAA4CC,iBAA5C,CAFyC,CAA5C,CAIA,GAAMa,CAAAA,0BAA0B,CAAGnF,OAAO,CACxC,iBAAMoF,CAAAA,IAAI,CAACC,SAAL,CAAeH,4BAA4B,CAACI,IAA7B,EAAf,CAAN,EADwC,CAExC,CAACJ,4BAAD,CAFwC,CAA1C,CAKAnF,SAAS,CAAC,UAAM,CACd,GAAI,CAACuE,iBAAD,EAAsB,CAACnB,OAAvB,EAAkC,CAAC6B,kBAAvC,CAA2D,OAE3D,GAAMO,CAAAA,gBAA0B,CAAGH,IAAI,CAACI,KAAL,CAAWL,0BAAX,CAAnC,CACA,GAAII,gBAAgB,CAAChD,MAAjB,GAA4B,CAAhC,CAAmC,OACnC,GAAMkD,CAAAA,KAAK,CAAGF,gBAAgB,CAAChE,GAAjB,CAAqB,SAACqC,GAAD,QAAS9C,CAAAA,YAAY,CAAC8C,GAAD,CAArB,EAArB,CAAd,CAEA,GAAM8B,CAAAA,YAAY,CAAGrF,UAAU,CAACoF,KAAD,CAA/B,CAEA,GAAIR,aAAa,CAACjB,OAAd,EAAyBiB,aAAa,CAACjB,OAAd,CAAsB7C,WAAtB,GAAsCmD,iBAAnE,CAAsF,CACpFW,aAAa,CAACjB,OAAd,CAAsBiB,aAAtB,CAAoC9C,OAApC,CAA4C,SAACwD,CAAD,QAAOA,CAAAA,CAAC,EAAR,EAA5C,EACD,CAEDf,QAAQ,CACNlE,wBAAwB,CAAC,CACvB+E,KAAK,CAALA,KADuB,CAEvBtC,OAAO,CAAPA,OAFuB,CAGvBuB,mBAAmB,CAAEJ,iBAHE,CAAD,CADlB,CAAR,CAQAW,aAAa,CAACjB,OAAd,CAAwB,CACtB7C,WAAW,CAAEmD,iBADS,CAEtBW,aAAa,CAAES,YAAY,CAACnE,GAAb,CAAiB,SAACL,KAAD,CAAQ0E,KAAR,CAAkB,CAChD,WAA4BtF,KAAK,CAAC,iBAAMU,CAAAA,UAAU,CAACgE,kBAAD,CAAqB9D,KAArB,CAA4BoD,iBAA5B,CAAhB,EAAD,CAAiE,CAChGuB,CAAC,CAAE3B,QAD6F,CAEhG4B,OAAO,CAAE,IAFuF,CAGhGC,OAAO,CAAE,IAHuF,CAAjE,CAAjC,CAAQC,MAAR,QAAQA,MAAR,CAAgBC,OAAhB,QAAgBA,OAAhB,CAKAA,OAAO,CACJC,IADH,CACQ,SAACnE,UAAD,CAAgB,CACpB;AACA,GAAMoE,CAAAA,iBAAiB,CAAGT,YAAY,CAACU,KAAb,CAAmB,CAAnB,CAAsBR,KAAtB,EAA6BrC,MAA7B,CAA4C,SAACC,IAAD,CAAO6C,IAAP,QAAgB7C,CAAAA,IAAI,CAAG6C,IAAI,CAAC9D,MAA5B,EAA5C,CAAgF,CAAhF,CAA1B,CACA,GAAM+D,CAAAA,gBAAgB,CAAGH,iBAAiB,CAAGpE,UAAU,CAACQ,MAAxD,CAEA,GAAM6D,CAAAA,KAAK,CAAGb,gBAAgB,CAACa,KAAjB,CAAuBD,iBAAvB,CAA0CG,gBAA1C,CAAd,CAEA;AACA,kBAAkCF,KAAK,CAAC7C,MAAN,CAIhC,SAACC,IAAD,CAAOC,OAAP,CAAgBrB,CAAhB,CAAsB,CACpB,GAAIL,UAAU,CAACK,CAAD,CAAV,CAAcE,OAAlB,CAA2B,2BACzBkB,IAAI,CAACe,OAAL,CAAad,OAAb,yBAAwB1B,UAAU,CAACK,CAAD,CAAV,CAAcL,UAAtC,+DAAoD,IAApD,CACD,CAFD,IAEO,CACLyB,IAAI,CAAC+C,YAAL,CAAkBC,IAAlB,CAAuB1F,YAAY,CAAC2C,OAAD,CAAnC,EACD,CACD,MAAOD,CAAAA,IAAP,CACD,CAX+B,CAYhC,CAAE+C,YAAY,CAAE,EAAhB,CAAoBhC,OAAO,CAAE,EAA7B,CAZgC,CAAlC,CAAQgC,YAAR,eAAQA,YAAR,CAAsBhC,OAAtB,eAAsBA,OAAtB,CAeA;AACA,GAAIlB,MAAM,CAACC,IAAP,CAAYiB,OAAZ,EAAqBhC,MAArB,CAA8B,CAAlC,CACEqC,QAAQ,CACNjE,sBAAsB,CAAC,CACrBwC,OAAO,CAAPA,OADqB,CAErBoB,OAAO,CAAPA,OAFqB,CAGrBpD,WAAW,CAAEmD,iBAHQ,CAAD,CADhB,CAAR,CAQF;AACA,GAAIiC,YAAY,CAAChE,MAAb,CAAsB,CAA1B,CAA6B,CAC3BnB,OAAO,CAACC,KAAR,CAAc,wBAAd,CAAwCkF,YAAxC,EACA3B,QAAQ,CACNnE,6BAA6B,CAAC,CAC5BgF,KAAK,CAAEc,YADqB,CAE5BpD,OAAO,CAAPA,OAF4B,CAG5BuB,mBAAmB,CAAEJ,iBAHO,CAAD,CADvB,CAAR,CAOD,CACF,CA7CH,EA8CGmC,KA9CH,CA8CS,SAACzD,KAAD,CAAgB,CACrB,GAAIA,KAAK,CAAC0D,gBAAV,CAA4B,CAC1BtF,OAAO,CAACC,KAAR,CAAc,iCAAd,CAAiDiD,iBAAjD,CAAoEpD,KAApE,CAA2EiC,OAA3E,EACA,OACD,CACD/B,OAAO,CAAC4B,KAAR,CAAc,iCAAd,CAAiD9B,KAAjD,CAAwDiC,OAAxD,CAAiEH,KAAjE,EACA4B,QAAQ,CACNnE,6BAA6B,CAAC,CAC5BgF,KAAK,CAAEvE,KADqB,CAE5BiC,OAAO,CAAPA,OAF4B,CAG5BuB,mBAAmB,CAAEJ,iBAHO,CAAD,CADvB,CAAR,CAOD,CA3DH,EA4DA,MAAO0B,CAAAA,MAAP,CACD,CAnEc,CAFO,CAAxB,CAuED,CA5FQ,CA4FN,CAAC7C,OAAD,CAAU6B,kBAAV,CAA8BJ,QAA9B,CAAwCO,0BAAxC,CAAoEb,iBAApE,CA5FM,CAAT,CA8FA,MAAO,KAAP,CACD","sourcesContent":["import { useEffect, useMemo, useRef } from 'react'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { useMulticall2Contract } from '../../hooks/useContract'\nimport useDebounce from '../../hooks/useDebounce'\nimport chunkArray from '../../utils/chunkArray'\nimport { retry, RetryableError } from '../../utils/retry'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppState } from '../index'\nimport { errorFetchingMulticallResults, fetchingMulticallResults, updateMulticallResults } from './actions'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { Call, parseCallKey } from './utils'\nimport { UniswapInterfaceMulticall } from 'types/v3'\n\nconst DEFAULT_GAS_REQUIRED = 1_000_000\n\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicall multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param blockNumber block number passed as the block tag in the eth_call\n */\nasync function fetchChunk(\n  multicall: UniswapInterfaceMulticall,\n  chunk: Call[],\n  blockNumber: number\n): Promise<{ success: boolean; returnData: string }[]> {\n  console.debug('Fetching chunk', chunk, blockNumber)\n  try {\n    const { returnData } = await multicall.callStatic.multicall(\n      chunk.map((obj) => ({\n        target: obj.address,\n        callData: obj.callData,\n        gasLimit: obj.gasRequired ?? DEFAULT_GAS_REQUIRED,\n      })),\n      { blockTag: blockNumber }\n    )\n\n    if (process.env.NODE_ENV === 'development') {\n      returnData.forEach(({ gasUsed, returnData, success }, i) => {\n        if (\n          !success &&\n          returnData.length === 2 &&\n          gasUsed.gte(Math.floor((chunk[i].gasRequired ?? DEFAULT_GAS_REQUIRED) * 0.95))\n        ) {\n          console.warn(\n            `A call failed due to requiring ${gasUsed.toString()} vs. allowed ${\n              chunk[i].gasRequired ?? DEFAULT_GAS_REQUIRED\n            }`,\n            chunk[i]\n          )\n        }\n      })\n    }\n\n    return returnData\n  } catch (error) {\n    if (error.code === -32000 || error.message?.indexOf('header not found') !== -1) {\n      throw new RetryableError(`header not found for block number ${blockNumber}`)\n    }\n    console.error('Failed to fetch chunk', error)\n    throw error\n  }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter((key) => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter((callKey) => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport default function Updater(): null {\n  const dispatch = useAppDispatch()\n  const state = useAppSelector((state) => state.multicall)\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const latestBlockNumber = useBlockNumber()\n  const { chainId } = useActiveWeb3React()\n  const multicall2Contract = useMulticall2Contract()\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId)\n  }, [debouncedListeners, chainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\n    [unserializedOutdatedCallKeys]\n  )\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !multicall2Contract) return\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\n\n    const chunkedCalls = chunkArray(calls)\n\n    if (cancellations.current && cancellations.current.blockNumber !== latestBlockNumber) {\n      cancellations.current.cancellations.forEach((c) => c())\n    }\n\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      })\n    )\n\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const { cancel, promise } = retry(() => fetchChunk(multicall2Contract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 1000,\n          maxWait: 2500,\n        })\n        promise\n          .then((returnData) => {\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\n\n            const slice = outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex)\n\n            // split the returned slice into errors and success\n            const { erroredCalls, results } = slice.reduce<{\n              erroredCalls: Call[]\n              results: { [callKey: string]: string | null }\n            }>(\n              (memo, callKey, i) => {\n                if (returnData[i].success) {\n                  memo.results[callKey] = returnData[i].returnData ?? null\n                } else {\n                  memo.erroredCalls.push(parseCallKey(callKey))\n                }\n                return memo\n              },\n              { erroredCalls: [], results: {} }\n            )\n\n            // dispatch any new results\n            if (Object.keys(results).length > 0)\n              dispatch(\n                updateMulticallResults({\n                  chainId,\n                  results,\n                  blockNumber: latestBlockNumber,\n                })\n              )\n\n            // dispatch any errored calls\n            if (erroredCalls.length > 0) {\n              console.debug('Calls errored in fetch', erroredCalls)\n              dispatch(\n                errorFetchingMulticallResults({\n                  calls: erroredCalls,\n                  chainId,\n                  fetchingBlockNumber: latestBlockNumber,\n                })\n              )\n            }\n          })\n          .catch((error: any) => {\n            if (error.isCancelledError) {\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber, chunk, chainId)\n              return\n            }\n            console.error('Failed to fetch multicall chunk', chunk, chainId, error)\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId,\n                fetchingBlockNumber: latestBlockNumber,\n              })\n            )\n          })\n        return cancel\n      }),\n    }\n  }, [chainId, multicall2Contract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}