{"ast":null,"code":"import _slicedToArray from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{computePoolAddress}from'@uniswap/v3-sdk';import{V3_CORE_FACTORY_ADDRESSES}from'../constants/addresses';import{useMemo}from'react';import{useActiveWeb3React}from'./web3';import{useMultipleContractSingleData}from'../state/multicall/hooks';import{Pool}from'@uniswap/v3-sdk';import{abi as IUniswapV3PoolStateABI}from'@uniswap/v3-core/artifacts/contracts/interfaces/pool/IUniswapV3PoolState.sol/IUniswapV3PoolState.json';import{Interface}from'@ethersproject/abi';var POOL_STATE_INTERFACE=new Interface(IUniswapV3PoolStateABI);export var PoolState;(function(PoolState){PoolState[PoolState[\"LOADING\"]=0]=\"LOADING\";PoolState[PoolState[\"NOT_EXISTS\"]=1]=\"NOT_EXISTS\";PoolState[PoolState[\"EXISTS\"]=2]=\"EXISTS\";PoolState[PoolState[\"INVALID\"]=3]=\"INVALID\";})(PoolState||(PoolState={}));export function usePools(poolKeys){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var transformed=useMemo(function(){return poolKeys.map(function(_ref){var _ref2=_slicedToArray(_ref,3),currencyA=_ref2[0],currencyB=_ref2[1],feeAmount=_ref2[2];if(!chainId||!currencyA||!currencyB||!feeAmount)return null;var tokenA=currencyA===null||currencyA===void 0?void 0:currencyA.wrapped;var tokenB=currencyB===null||currencyB===void 0?void 0:currencyB.wrapped;if(!tokenA||!tokenB||tokenA.equals(tokenB))return null;var _ref3=tokenA.sortsBefore(tokenB)?[tokenA,tokenB]:[tokenB,tokenA],_ref4=_slicedToArray(_ref3,2),token0=_ref4[0],token1=_ref4[1];return[token0,token1,feeAmount];});},[chainId,poolKeys]);var poolAddresses=useMemo(function(){var v3CoreFactoryAddress=chainId&&V3_CORE_FACTORY_ADDRESSES[chainId];return transformed.map(function(value){if(!v3CoreFactoryAddress||!value)return undefined;return computePoolAddress({factoryAddress:v3CoreFactoryAddress,tokenA:value[0],tokenB:value[1],fee:value[2]});});},[chainId,transformed]);var slot0s=useMultipleContractSingleData(poolAddresses,POOL_STATE_INTERFACE,'slot0');var liquidities=useMultipleContractSingleData(poolAddresses,POOL_STATE_INTERFACE,'liquidity');return useMemo(function(){return poolKeys.map(function(_key,index){var _transformed$index;var _ref5=(_transformed$index=transformed[index])!==null&&_transformed$index!==void 0?_transformed$index:[],_ref6=_slicedToArray(_ref5,3),token0=_ref6[0],token1=_ref6[1],fee=_ref6[2];if(!token0||!token1||!fee)return[PoolState.INVALID,null];var _slot0s$index=slot0s[index],slot0=_slot0s$index.result,slot0Loading=_slot0s$index.loading,slot0Valid=_slot0s$index.valid;var _liquidities$index=liquidities[index],liquidity=_liquidities$index.result,liquidityLoading=_liquidities$index.loading,liquidityValid=_liquidities$index.valid;if(!slot0Valid||!liquidityValid)return[PoolState.INVALID,null];if(slot0Loading||liquidityLoading)return[PoolState.LOADING,null];if(!slot0||!liquidity)return[PoolState.NOT_EXISTS,null];if(!slot0.sqrtPriceX96||slot0.sqrtPriceX96.eq(0))return[PoolState.NOT_EXISTS,null];try{return[PoolState.EXISTS,new Pool(token0,token1,fee,slot0.sqrtPriceX96,liquidity[0],slot0.tick)];}catch(error){console.error('Error when constructing the pool',error);return[PoolState.NOT_EXISTS,null];}});},[liquidities,poolKeys,slot0s,transformed]);}export function usePool(currencyA,currencyB,feeAmount){var poolKeys=useMemo(function(){return[[currencyA,currencyB,feeAmount]];},[currencyA,currencyB,feeAmount]);return usePools(poolKeys)[0];}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/hooks/usePools.ts"],"names":["computePoolAddress","V3_CORE_FACTORY_ADDRESSES","useMemo","useActiveWeb3React","useMultipleContractSingleData","Pool","abi","IUniswapV3PoolStateABI","Interface","POOL_STATE_INTERFACE","PoolState","usePools","poolKeys","chainId","transformed","map","currencyA","currencyB","feeAmount","tokenA","wrapped","tokenB","equals","sortsBefore","token0","token1","poolAddresses","v3CoreFactoryAddress","value","undefined","factoryAddress","fee","slot0s","liquidities","_key","index","INVALID","slot0","result","slot0Loading","loading","slot0Valid","valid","liquidity","liquidityLoading","liquidityValid","LOADING","NOT_EXISTS","sqrtPriceX96","eq","EXISTS","tick","error","console","usePool"],"mappings":"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","sourcesContent":["import { computePoolAddress } from '@uniswap/v3-sdk'\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses'\nimport { IUniswapV3PoolStateInterface } from '../types/v3/IUniswapV3PoolState'\nimport { Token, Currency } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\nimport { useActiveWeb3React } from './web3'\nimport { useMultipleContractSingleData } from '../state/multicall/hooks'\n\nimport { Pool, FeeAmount } from '@uniswap/v3-sdk'\nimport { abi as IUniswapV3PoolStateABI } from '@uniswap/v3-core/artifacts/contracts/interfaces/pool/IUniswapV3PoolState.sol/IUniswapV3PoolState.json'\nimport { Interface } from '@ethersproject/abi'\n\nconst POOL_STATE_INTERFACE = new Interface(IUniswapV3PoolStateABI) as IUniswapV3PoolStateInterface\n\nexport enum PoolState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n\nexport function usePools(\n  poolKeys: [Currency | undefined, Currency | undefined, FeeAmount | undefined][]\n): [PoolState, Pool | null][] {\n  const { chainId } = useActiveWeb3React()\n\n  const transformed: ([Token, Token, FeeAmount] | null)[] = useMemo(() => {\n    return poolKeys.map(([currencyA, currencyB, feeAmount]) => {\n      if (!chainId || !currencyA || !currencyB || !feeAmount) return null\n\n      const tokenA = currencyA?.wrapped\n      const tokenB = currencyB?.wrapped\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return null\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n      return [token0, token1, feeAmount]\n    })\n  }, [chainId, poolKeys])\n\n  const poolAddresses: (string | undefined)[] = useMemo(() => {\n    const v3CoreFactoryAddress = chainId && V3_CORE_FACTORY_ADDRESSES[chainId]\n\n    return transformed.map((value) => {\n      if (!v3CoreFactoryAddress || !value) return undefined\n      return computePoolAddress({\n        factoryAddress: v3CoreFactoryAddress,\n        tokenA: value[0],\n        tokenB: value[1],\n        fee: value[2],\n      })\n    })\n  }, [chainId, transformed])\n\n  const slot0s = useMultipleContractSingleData(poolAddresses, POOL_STATE_INTERFACE, 'slot0')\n  const liquidities = useMultipleContractSingleData(poolAddresses, POOL_STATE_INTERFACE, 'liquidity')\n\n  return useMemo(() => {\n    return poolKeys.map((_key, index) => {\n      const [token0, token1, fee] = transformed[index] ?? []\n      if (!token0 || !token1 || !fee) return [PoolState.INVALID, null]\n\n      const { result: slot0, loading: slot0Loading, valid: slot0Valid } = slot0s[index]\n      const { result: liquidity, loading: liquidityLoading, valid: liquidityValid } = liquidities[index]\n\n      if (!slot0Valid || !liquidityValid) return [PoolState.INVALID, null]\n      if (slot0Loading || liquidityLoading) return [PoolState.LOADING, null]\n\n      if (!slot0 || !liquidity) return [PoolState.NOT_EXISTS, null]\n\n      if (!slot0.sqrtPriceX96 || slot0.sqrtPriceX96.eq(0)) return [PoolState.NOT_EXISTS, null]\n\n      try {\n        return [PoolState.EXISTS, new Pool(token0, token1, fee, slot0.sqrtPriceX96, liquidity[0], slot0.tick)]\n      } catch (error) {\n        console.error('Error when constructing the pool', error)\n        return [PoolState.NOT_EXISTS, null]\n      }\n    })\n  }, [liquidities, poolKeys, slot0s, transformed])\n}\n\nexport function usePool(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): [PoolState, Pool | null] {\n  const poolKeys: [Currency | undefined, Currency | undefined, FeeAmount | undefined][] = useMemo(\n    () => [[currencyA, currencyB, feeAmount]],\n    [currencyA, currencyB, feeAmount]\n  )\n\n  return usePools(poolKeys)[0]\n}\n"]},"metadata":{},"sourceType":"module"}