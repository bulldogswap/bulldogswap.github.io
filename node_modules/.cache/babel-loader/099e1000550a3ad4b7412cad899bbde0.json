{"ast":null,"code":"import _objectSpread from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import DEFAULT_TOKEN_LIST from'@uniswap/default-token-list';import{IS_ON_APP_URL}from'constants/misc';import{useMemo}from'react';import{useAppSelector}from'state/hooks';import sortByListPriority from'utils/listSort';import UNSUPPORTED_TOKEN_LIST from'../../constants/tokenLists/unsupported.tokenlist.json';import BROKEN_LIST from'../../constants/tokenLists/broken.tokenlist.json';import{UNSUPPORTED_LIST_URLS}from'./../../constants/lists';import{WrappedTokenInfo}from'./wrappedTokenInfo';var listCache=typeof WeakMap!=='undefined'?new WeakMap():null;function listToTokenMap(list){var result=listCache===null||listCache===void 0?void 0:listCache.get(list);if(result)return result;var map=list.tokens.reduce(function(tokenMap,tokenInfo){var _tokenMap$token$chain;var token=new WrappedTokenInfo(tokenInfo,list);if(((_tokenMap$token$chain=tokenMap[token.chainId])===null||_tokenMap$token$chain===void 0?void 0:_tokenMap$token$chain[token.address])!==undefined){console.error(\"Duplicate token! \".concat(token.address));return tokenMap;}if(!tokenMap[token.chainId])tokenMap[token.chainId]={};tokenMap[token.chainId][token.address]={token:token,list:list};return tokenMap;},{});listCache===null||listCache===void 0?void 0:listCache.set(list,map);return map;}var TRANSFORMED_DEFAULT_TOKEN_LIST=listToTokenMap(DEFAULT_TOKEN_LIST);export function useAllLists(){return useAppSelector(function(state){return state.lists.byUrl;});}/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */export function combineMaps(map1,map2){var chainIds=Object.keys(Object.keys(map1).concat(Object.keys(map2)).reduce(function(memo,value){memo[value]=true;return memo;},{})).map(function(id){return parseInt(id);});return chainIds.reduce(function(memo,chainId){memo[chainId]=_objectSpread(_objectSpread({},map2[chainId]),map1[chainId]);return memo;},{});}// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls){var lists=useAllLists();return useMemo(function(){if(!urls)return{};return urls.slice()// sort by priority so top priority goes last\n.sort(sortByListPriority).reduce(function(allTokens,currentUrl){var _lists$currentUrl;var current=(_lists$currentUrl=lists[currentUrl])===null||_lists$currentUrl===void 0?void 0:_lists$currentUrl.current;if(!current)return allTokens;try{return combineMaps(allTokens,listToTokenMap(current));}catch(error){console.error('Could not show token list due to error',error);return allTokens;}},{});},[lists,urls]);}// filter out unsupported lists\nexport function useActiveListUrls(){var _useAppSelector;return(_useAppSelector=useAppSelector(function(state){return state.lists.activeListUrls;}))===null||_useAppSelector===void 0?void 0:_useAppSelector.filter(function(url){return!UNSUPPORTED_LIST_URLS.includes(url);});}export function useInactiveListUrls(){var lists=useAllLists();var allActiveListUrls=useActiveListUrls();return Object.keys(lists).filter(function(url){return!(allActiveListUrls===null||allActiveListUrls===void 0?void 0:allActiveListUrls.includes(url))&&!UNSUPPORTED_LIST_URLS.includes(url);});}// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(){var activeListUrls=useActiveListUrls();var activeTokens=useCombinedTokenMapFromUrls(activeListUrls);return combineMaps(activeTokens,TRANSFORMED_DEFAULT_TOKEN_LIST);}// list of tokens not supported on interface, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(){// get hard coded unsupported tokens, only block on app url\nvar localUnsupportedListMap=useMemo(function(){return IS_ON_APP_URL?listToTokenMap(UNSUPPORTED_TOKEN_LIST):{};},[]);// broken tokens, blocked on all URLS\nvar brokenListMap=useMemo(function(){return listToTokenMap(BROKEN_LIST);},[]);// get any loaded unsupported tokens, this will be empty if not on app URL\nvar loadedUnsupportedListMap=useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS);// format into one token address map\nreturn useMemo(function(){return combineMaps(brokenListMap,combineMaps(localUnsupportedListMap,loadedUnsupportedListMap));},[localUnsupportedListMap,loadedUnsupportedListMap,brokenListMap]);}export function useIsListActive(url){var activeListUrls=useActiveListUrls();return Boolean(activeListUrls===null||activeListUrls===void 0?void 0:activeListUrls.includes(url));}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/state/lists/hooks.ts"],"names":["DEFAULT_TOKEN_LIST","IS_ON_APP_URL","useMemo","useAppSelector","sortByListPriority","UNSUPPORTED_TOKEN_LIST","BROKEN_LIST","UNSUPPORTED_LIST_URLS","WrappedTokenInfo","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tokenInfo","token","chainId","address","undefined","console","error","set","TRANSFORMED_DEFAULT_TOKEN_LIST","useAllLists","state","lists","byUrl","combineMaps","map1","map2","chainIds","Object","keys","concat","memo","value","id","parseInt","useCombinedTokenMapFromUrls","urls","slice","sort","allTokens","currentUrl","current","useActiveListUrls","activeListUrls","filter","url","includes","useInactiveListUrls","allActiveListUrls","useCombinedActiveList","activeTokens","useUnsupportedTokenList","localUnsupportedListMap","brokenListMap","loadedUnsupportedListMap","useIsListActive","Boolean"],"mappings":"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","sourcesContent":["import DEFAULT_TOKEN_LIST from '@uniswap/default-token-list'\nimport { TokenList } from '@uniswap/token-lists'\nimport { IS_ON_APP_URL } from 'constants/misc'\nimport { useMemo } from 'react'\nimport { useAppSelector } from 'state/hooks'\nimport sortByListPriority from 'utils/listSort'\nimport UNSUPPORTED_TOKEN_LIST from '../../constants/tokenLists/unsupported.tokenlist.json'\nimport BROKEN_LIST from '../../constants/tokenLists/broken.tokenlist.json'\nimport { AppState } from '../index'\nimport { UNSUPPORTED_LIST_URLS } from './../../constants/lists'\nimport { WrappedTokenInfo } from './wrappedTokenInfo'\n\nexport type TokenAddressMap = Readonly<{\n  [chainId: number]: Readonly<{ [tokenAddress: string]: { token: WrappedTokenInfo; list: TokenList } }>\n}>\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: Mutable<T[P]>\n}\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  typeof WeakMap !== 'undefined' ? new WeakMap<TokenList, TokenAddressMap>() : null\n\nfunction listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list)\n  if (result) return result\n\n  const map = list.tokens.reduce<Mutable<TokenAddressMap>>((tokenMap, tokenInfo) => {\n    const token = new WrappedTokenInfo(tokenInfo, list)\n    if (tokenMap[token.chainId]?.[token.address] !== undefined) {\n      console.error(`Duplicate token! ${token.address}`)\n      return tokenMap\n    }\n    if (!tokenMap[token.chainId]) tokenMap[token.chainId] = {}\n    tokenMap[token.chainId][token.address] = {\n      token,\n      list,\n    }\n    return tokenMap\n  }, {}) as TokenAddressMap\n  listCache?.set(list, map)\n  return map\n}\n\nconst TRANSFORMED_DEFAULT_TOKEN_LIST = listToTokenMap(DEFAULT_TOKEN_LIST)\n\nexport function useAllLists(): AppState['lists']['byUrl'] {\n  return useAppSelector((state) => state.lists.byUrl)\n}\n\n/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */\nexport function combineMaps(map1: TokenAddressMap, map2: TokenAddressMap): TokenAddressMap {\n  const chainIds = Object.keys(\n    Object.keys(map1)\n      .concat(Object.keys(map2))\n      .reduce<{ [chainId: string]: true }>((memo, value) => {\n        memo[value] = true\n        return memo\n      }, {})\n  ).map((id) => parseInt(id))\n\n  return chainIds.reduce<Mutable<TokenAddressMap>>((memo, chainId) => {\n    memo[chainId] = {\n      ...map2[chainId],\n      // map1 takes precedence\n      ...map1[chainId],\n    }\n    return memo\n  }, {}) as TokenAddressMap\n}\n\n// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls: string[] | undefined): TokenAddressMap {\n  const lists = useAllLists()\n  return useMemo(() => {\n    if (!urls) return {}\n    return (\n      urls\n        .slice()\n        // sort by priority so top priority goes last\n        .sort(sortByListPriority)\n        .reduce((allTokens, currentUrl) => {\n          const current = lists[currentUrl]?.current\n          if (!current) return allTokens\n          try {\n            return combineMaps(allTokens, listToTokenMap(current))\n          } catch (error) {\n            console.error('Could not show token list due to error', error)\n            return allTokens\n          }\n        }, {})\n    )\n  }, [lists, urls])\n}\n\n// filter out unsupported lists\nexport function useActiveListUrls(): string[] | undefined {\n  return useAppSelector((state) => state.lists.activeListUrls)?.filter((url) => !UNSUPPORTED_LIST_URLS.includes(url))\n}\n\nexport function useInactiveListUrls(): string[] {\n  const lists = useAllLists()\n  const allActiveListUrls = useActiveListUrls()\n  return Object.keys(lists).filter((url) => !allActiveListUrls?.includes(url) && !UNSUPPORTED_LIST_URLS.includes(url))\n}\n\n// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(): TokenAddressMap {\n  const activeListUrls = useActiveListUrls()\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls)\n  return combineMaps(activeTokens, TRANSFORMED_DEFAULT_TOKEN_LIST)\n}\n\n// list of tokens not supported on interface, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(): TokenAddressMap {\n  // get hard coded unsupported tokens, only block on app url\n  const localUnsupportedListMap = useMemo(() => (IS_ON_APP_URL ? listToTokenMap(UNSUPPORTED_TOKEN_LIST) : {}), [])\n\n  // broken tokens, blocked on all URLS\n  const brokenListMap = useMemo(() => listToTokenMap(BROKEN_LIST), [])\n\n  // get any loaded unsupported tokens, this will be empty if not on app URL\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS)\n\n  // format into one token address map\n  return useMemo(\n    () => combineMaps(brokenListMap, combineMaps(localUnsupportedListMap, loadedUnsupportedListMap)),\n    [localUnsupportedListMap, loadedUnsupportedListMap, brokenListMap]\n  )\n}\n\nexport function useIsListActive(url: string): boolean {\n  const activeListUrls = useActiveListUrls()\n  return Boolean(activeListUrls?.includes(url))\n}\n"]},"metadata":{},"sourceType":"module"}