{"ast":null,"code":"import{Pool,tickToPrice,TICK_SPACINGS}from'@uniswap/v3-sdk';import JSBI from'jsbi';import{PoolState,usePool}from'./usePools';import{useMemo}from'react';import computeSurroundingTicks from'utils/computeSurroundingTicks';import{useAllV3TicksQuery}from'state/data/enhanced';import{skipToken}from'@reduxjs/toolkit/query/react';var PRICE_FIXED_DIGITS=8;// Tick with fields parsed to JSBIs, and active liquidity computed.\nvar getActiveTick=function getActiveTick(tickCurrent,feeAmount){return tickCurrent&&feeAmount?Math.floor(tickCurrent/TICK_SPACINGS[feeAmount])*TICK_SPACINGS[feeAmount]:undefined;};// Fetches all ticks for a given pool\nexport function useAllV3Ticks(currencyA,currencyB,feeAmount){var poolAddress=currencyA&&currencyB&&feeAmount?Pool.getAddress(currencyA===null||currencyA===void 0?void 0:currencyA.wrapped,currencyB===null||currencyB===void 0?void 0:currencyB.wrapped,feeAmount):undefined;//TODO(judo): determine if pagination is necessary for this query\nvar _useAllV3TicksQuery=useAllV3TicksQuery(poolAddress?{poolAddress:poolAddress===null||poolAddress===void 0?void 0:poolAddress.toLowerCase(),skip:0}:skipToken,{pollingInterval:120000}),isLoading=_useAllV3TicksQuery.isLoading,isError=_useAllV3TicksQuery.isError,error=_useAllV3TicksQuery.error,isUninitialized=_useAllV3TicksQuery.isUninitialized,data=_useAllV3TicksQuery.data;return{isLoading:isLoading,isUninitialized:isUninitialized,isError:isError,error:error,ticks:data===null||data===void 0?void 0:data.ticks};}export function usePoolActiveLiquidity(currencyA,currencyB,feeAmount){var pool=usePool(currencyA,currencyB,feeAmount);// Find nearest valid tick for pool in case tick is not initialized.\nvar activeTick=useMemo(function(){var _pool$;return getActiveTick((_pool$=pool[1])===null||_pool$===void 0?void 0:_pool$.tickCurrent,feeAmount);},[pool,feeAmount]);var _useAllV3Ticks=useAllV3Ticks(currencyA,currencyB,feeAmount),isLoading=_useAllV3Ticks.isLoading,isUninitialized=_useAllV3Ticks.isUninitialized,isError=_useAllV3Ticks.isError,error=_useAllV3Ticks.error,ticks=_useAllV3Ticks.ticks;return useMemo(function(){var _pool$1$liquidity,_pool$2;if(!currencyA||!currencyB||activeTick===undefined||pool[0]!==PoolState.EXISTS||!ticks||ticks.length===0||isLoading||isUninitialized){return{isLoading:isLoading||pool[0]===PoolState.LOADING,isUninitialized:isUninitialized,isError:isError,error:error,activeTick:activeTick,data:undefined};}var token0=currencyA===null||currencyA===void 0?void 0:currencyA.wrapped;var token1=currencyB===null||currencyB===void 0?void 0:currencyB.wrapped;// find where the active tick would be to partition the array\n// if the active tick is initialized, the pivot will be an element\n// if not, take the previous tick as pivot\nvar pivot=ticks.findIndex(function(_ref){var tickIdx=_ref.tickIdx;return tickIdx>activeTick;})-1;if(pivot<0){// consider setting a local error\nconsole.error('TickData pivot not found');return{isLoading:isLoading,isUninitialized:isUninitialized,isError:isError,error:error,activeTick:activeTick,data:undefined};}var activeTickProcessed={liquidityActive:JSBI.BigInt((_pool$1$liquidity=(_pool$2=pool[1])===null||_pool$2===void 0?void 0:_pool$2.liquidity)!==null&&_pool$1$liquidity!==void 0?_pool$1$liquidity:0),tickIdx:activeTick,liquidityNet:Number(ticks[pivot].tickIdx)===activeTick?JSBI.BigInt(ticks[pivot].liquidityNet):JSBI.BigInt(0),price0:tickToPrice(token0,token1,activeTick).toFixed(PRICE_FIXED_DIGITS)};var subsequentTicks=computeSurroundingTicks(token0,token1,activeTickProcessed,ticks,pivot,true);var previousTicks=computeSurroundingTicks(token0,token1,activeTickProcessed,ticks,pivot,false);var ticksProcessed=previousTicks.concat(activeTickProcessed).concat(subsequentTicks);return{isLoading:isLoading,isUninitialized:isUninitialized,isError:isError,error:error,activeTick:activeTick,data:ticksProcessed};},[currencyA,currencyB,activeTick,pool,ticks,isLoading,isUninitialized,isError,error]);}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/hooks/usePoolTickData.ts"],"names":["Pool","tickToPrice","TICK_SPACINGS","JSBI","PoolState","usePool","useMemo","computeSurroundingTicks","useAllV3TicksQuery","skipToken","PRICE_FIXED_DIGITS","getActiveTick","tickCurrent","feeAmount","Math","floor","undefined","useAllV3Ticks","currencyA","currencyB","poolAddress","getAddress","wrapped","toLowerCase","skip","pollingInterval","isLoading","isError","error","isUninitialized","data","ticks","usePoolActiveLiquidity","pool","activeTick","EXISTS","length","LOADING","token0","token1","pivot","findIndex","tickIdx","console","activeTickProcessed","liquidityActive","BigInt","liquidity","liquidityNet","Number","price0","toFixed","subsequentTicks","previousTicks","ticksProcessed","concat"],"mappings":"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","sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { FeeAmount, Pool, tickToPrice, TICK_SPACINGS } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\nimport { PoolState, usePool } from './usePools'\nimport { useMemo } from 'react'\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks'\nimport { useAllV3TicksQuery } from 'state/data/enhanced'\nimport { skipToken } from '@reduxjs/toolkit/query/react'\nimport ms from 'ms.macro'\nimport { AllV3TicksQuery } from 'state/data/generated'\n\nconst PRICE_FIXED_DIGITS = 8\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\nexport interface TickProcessed {\n  tickIdx: number\n  liquidityActive: JSBI\n  liquidityNet: JSBI\n  price0: string\n}\n\nconst getActiveTick = (tickCurrent: number | undefined, feeAmount: FeeAmount | undefined) =>\n  tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined\n\n// Fetches all ticks for a given pool\nexport function useAllV3Ticks(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n) {\n  const poolAddress =\n    currencyA && currencyB && feeAmount ? Pool.getAddress(currencyA?.wrapped, currencyB?.wrapped, feeAmount) : undefined\n\n  //TODO(judo): determine if pagination is necessary for this query\n  const { isLoading, isError, error, isUninitialized, data } = useAllV3TicksQuery(\n    poolAddress ? { poolAddress: poolAddress?.toLowerCase(), skip: 0 } : skipToken,\n    {\n      pollingInterval: ms`2m`,\n    }\n  )\n\n  return {\n    isLoading,\n    isUninitialized,\n    isError,\n    error,\n    ticks: data?.ticks as AllV3TicksQuery['ticks'],\n  }\n}\n\nexport function usePoolActiveLiquidity(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): {\n  isLoading: boolean\n  isUninitialized: boolean\n  isError: boolean\n  error: any\n  activeTick: number | undefined\n  data: TickProcessed[] | undefined\n} {\n  const pool = usePool(currencyA, currencyB, feeAmount)\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = useMemo(() => getActiveTick(pool[1]?.tickCurrent, feeAmount), [pool, feeAmount])\n\n  const { isLoading, isUninitialized, isError, error, ticks } = useAllV3Ticks(currencyA, currencyB, feeAmount)\n\n  return useMemo(() => {\n    if (\n      !currencyA ||\n      !currencyB ||\n      activeTick === undefined ||\n      pool[0] !== PoolState.EXISTS ||\n      !ticks ||\n      ticks.length === 0 ||\n      isLoading ||\n      isUninitialized\n    ) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        isUninitialized,\n        isError,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const token0 = currencyA?.wrapped\n    const token1 = currencyB?.wrapped\n\n    // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n    const pivot = ticks.findIndex(({ tickIdx }) => tickIdx > activeTick) - 1\n\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found')\n      return {\n        isLoading,\n        isUninitialized,\n        isError,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const activeTickProcessed: TickProcessed = {\n      liquidityActive: JSBI.BigInt(pool[1]?.liquidity ?? 0),\n      tickIdx: activeTick,\n      liquidityNet:\n        Number(ticks[pivot].tickIdx) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true)\n\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false)\n\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)\n\n    return {\n      isLoading,\n      isUninitialized,\n      isError: isError,\n      error,\n      activeTick,\n      data: ticksProcessed,\n    }\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, isUninitialized, isError, error])\n}\n"]},"metadata":{},"sourceType":"module"}