{"ast":null,"code":"import _slicedToArray from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{i18n}from\"@lingui/core\";import{BIG_INT_ZERO}from'../../../constants/misc';import{getTickToPrice}from'utils/getTickToPrice';import JSBI from'jsbi';import{PoolState}from'../../../hooks/usePools';import{Pool,Position,priceToClosestTick,TickMath,tickToPrice,TICK_SPACINGS,encodeSqrtRatioX96,nearestUsableTick}from'@uniswap/v3-sdk/dist/';import{CurrencyAmount,Price,Rounding}from'@uniswap/sdk-core';import{useCallback,useMemo}from'react';import{useActiveWeb3React}from'../../../hooks/web3';import{tryParseAmount}from'../../swap/hooks';import{useCurrencyBalances}from'../../wallet/hooks';import{Field,Bound,typeInput,typeStartPriceInput,typeLeftRangeInput,typeRightRangeInput,setFullRange}from'./actions';import{tryParseTick}from'./utils';import{usePool}from'hooks/usePools';import{useAppDispatch,useAppSelector}from'state/hooks';export function useV3MintState(){return useAppSelector(function(state){return state.mintV3;});}export function useV3MintActionHandlers(noLiquidity){var dispatch=useAppDispatch();var onFieldAInput=useCallback(function(typedValue){dispatch(typeInput({field:Field.CURRENCY_A,typedValue:typedValue,noLiquidity:noLiquidity===true}));},[dispatch,noLiquidity]);var onFieldBInput=useCallback(function(typedValue){dispatch(typeInput({field:Field.CURRENCY_B,typedValue:typedValue,noLiquidity:noLiquidity===true}));},[dispatch,noLiquidity]);var onLeftRangeInput=useCallback(function(typedValue){dispatch(typeLeftRangeInput({typedValue:typedValue}));},[dispatch]);var onRightRangeInput=useCallback(function(typedValue){dispatch(typeRightRangeInput({typedValue:typedValue}));},[dispatch]);var onStartPriceInput=useCallback(function(typedValue){dispatch(typeStartPriceInput({typedValue:typedValue}));},[dispatch]);return{onFieldAInput:onFieldAInput,onFieldBInput:onFieldBInput,onLeftRangeInput:onLeftRangeInput,onRightRangeInput:onRightRangeInput,onStartPriceInput:onStartPriceInput};}export function useV3DerivedMintInfo(currencyA,currencyB,feeAmount,baseCurrency,// override for existing position\nexistingPosition){var _currencyBalances,_currencyBalances$Fie,_currencyBalances$Fie2;var _useActiveWeb3React=useActiveWeb3React(),account=_useActiveWeb3React.account;var _useV3MintState=useV3MintState(),independentField=_useV3MintState.independentField,typedValue=_useV3MintState.typedValue,leftRangeTypedValue=_useV3MintState.leftRangeTypedValue,rightRangeTypedValue=_useV3MintState.rightRangeTypedValue,startPriceTypedValue=_useV3MintState.startPriceTypedValue;var dependentField=independentField===Field.CURRENCY_A?Field.CURRENCY_B:Field.CURRENCY_A;// currencies\nvar currencies=useMemo(function(){var _ref;return _ref={},_defineProperty(_ref,Field.CURRENCY_A,currencyA),_defineProperty(_ref,Field.CURRENCY_B,currencyB),_ref;},[currencyA,currencyB]);// formatted with tokens\nvar _useMemo=useMemo(function(){return[currencyA===null||currencyA===void 0?void 0:currencyA.wrapped,currencyB===null||currencyB===void 0?void 0:currencyB.wrapped,baseCurrency===null||baseCurrency===void 0?void 0:baseCurrency.wrapped];},[currencyA,currencyB,baseCurrency]),_useMemo2=_slicedToArray(_useMemo,3),tokenA=_useMemo2[0],tokenB=_useMemo2[1],baseToken=_useMemo2[2];var _useMemo3=useMemo(function(){return tokenA&&tokenB?tokenA.sortsBefore(tokenB)?[tokenA,tokenB]:[tokenB,tokenA]:[undefined,undefined];},[tokenA,tokenB]),_useMemo4=_slicedToArray(_useMemo3,2),token0=_useMemo4[0],token1=_useMemo4[1];// balances\nvar balances=useCurrencyBalances(account!==null&&account!==void 0?account:undefined,[currencies[Field.CURRENCY_A],currencies[Field.CURRENCY_B]]);var currencyBalances=(_currencyBalances={},_defineProperty(_currencyBalances,Field.CURRENCY_A,balances[0]),_defineProperty(_currencyBalances,Field.CURRENCY_B,balances[1]),_currencyBalances);// pool\nvar _usePool=usePool(currencies[Field.CURRENCY_A],currencies[Field.CURRENCY_B],feeAmount),_usePool2=_slicedToArray(_usePool,2),poolState=_usePool2[0],pool=_usePool2[1];var noLiquidity=poolState===PoolState.NOT_EXISTS;// note to parse inputs in reverse\nvar invertPrice=Boolean(baseToken&&token0&&!baseToken.equals(token0));// always returns the price with 0 as base token\nvar price=useMemo(function(){// if no liquidity use typed value\nif(noLiquidity){var parsedQuoteAmount=tryParseAmount(startPriceTypedValue,invertPrice?token0:token1);if(parsedQuoteAmount&&token0&&token1){var _ref2;var baseAmount=tryParseAmount('1',invertPrice?token1:token0);var _price=baseAmount&&parsedQuoteAmount?new Price(baseAmount.currency,parsedQuoteAmount.currency,baseAmount.quotient,parsedQuoteAmount.quotient):undefined;return(_ref2=invertPrice?_price===null||_price===void 0?void 0:_price.invert():_price)!==null&&_ref2!==void 0?_ref2:undefined;}return undefined;}else{// get the amount of quote currency\nreturn pool&&token0?pool.priceOf(token0):undefined;}},[noLiquidity,startPriceTypedValue,invertPrice,token1,token0,pool]);// check for invalid price input (converts to invalid ratio)\nvar invalidPrice=useMemo(function(){var sqrtRatioX96=price?encodeSqrtRatioX96(price.numerator,price.denominator):undefined;var invalid=price&&sqrtRatioX96&&!(JSBI.greaterThanOrEqual(sqrtRatioX96,TickMath.MIN_SQRT_RATIO)&&JSBI.lessThan(sqrtRatioX96,TickMath.MAX_SQRT_RATIO));return invalid;},[price]);// used for ratio calculation when pool not initialized\nvar mockPool=useMemo(function(){if(tokenA&&tokenB&&feeAmount&&price&&!invalidPrice){var currentTick=priceToClosestTick(price);var currentSqrt=TickMath.getSqrtRatioAtTick(currentTick);return new Pool(tokenA,tokenB,feeAmount,currentSqrt,JSBI.BigInt(0),currentTick,[]);}else{return undefined;}},[feeAmount,invalidPrice,price,tokenA,tokenB]);// if pool exists use it, if not use the mock pool\nvar poolForPosition=pool!==null&&pool!==void 0?pool:mockPool;// lower and upper limits in the tick space for `feeAmount`\nvar tickSpaceLimits=useMemo(function(){var _ref3;return _ref3={},_defineProperty(_ref3,Bound.LOWER,feeAmount?nearestUsableTick(TickMath.MIN_TICK,TICK_SPACINGS[feeAmount]):undefined),_defineProperty(_ref3,Bound.UPPER,feeAmount?nearestUsableTick(TickMath.MAX_TICK,TICK_SPACINGS[feeAmount]):undefined),_ref3;},[feeAmount]);// parse typed range values and determine closest ticks\n// lower should always be a smaller tick\nvar ticks=useMemo(function(){var _ref4;return _ref4={},_defineProperty(_ref4,Bound.LOWER,typeof(existingPosition===null||existingPosition===void 0?void 0:existingPosition.tickLower)==='number'?existingPosition.tickLower:invertPrice&&typeof rightRangeTypedValue==='boolean'||!invertPrice&&typeof leftRangeTypedValue==='boolean'?tickSpaceLimits[Bound.LOWER]:invertPrice?tryParseTick(token1,token0,feeAmount,rightRangeTypedValue.toString()):tryParseTick(token0,token1,feeAmount,leftRangeTypedValue.toString())),_defineProperty(_ref4,Bound.UPPER,typeof(existingPosition===null||existingPosition===void 0?void 0:existingPosition.tickUpper)==='number'?existingPosition.tickUpper:!invertPrice&&typeof rightRangeTypedValue==='boolean'||invertPrice&&typeof leftRangeTypedValue==='boolean'?tickSpaceLimits[Bound.UPPER]:invertPrice?tryParseTick(token1,token0,feeAmount,leftRangeTypedValue.toString()):tryParseTick(token0,token1,feeAmount,rightRangeTypedValue.toString())),_ref4;},[existingPosition,feeAmount,invertPrice,leftRangeTypedValue,rightRangeTypedValue,token0,token1,tickSpaceLimits]);var _ref5=ticks||{},tickLower=_ref5[Bound.LOWER],tickUpper=_ref5[Bound.UPPER];// specifies whether the lower and upper ticks is at the exteme bounds\nvar ticksAtLimit=useMemo(function(){var _ref6;return _ref6={},_defineProperty(_ref6,Bound.LOWER,feeAmount&&tickLower===tickSpaceLimits.LOWER),_defineProperty(_ref6,Bound.UPPER,feeAmount&&tickUpper===tickSpaceLimits.UPPER),_ref6;},[tickSpaceLimits,tickLower,tickUpper,feeAmount]);// mark invalid range\nvar invalidRange=Boolean(typeof tickLower==='number'&&typeof tickUpper==='number'&&tickLower>=tickUpper);// always returns the price with 0 as base token\nvar pricesAtTicks=useMemo(function(){var _ref7;return _ref7={},_defineProperty(_ref7,Bound.LOWER,getTickToPrice(token0,token1,ticks[Bound.LOWER])),_defineProperty(_ref7,Bound.UPPER,getTickToPrice(token0,token1,ticks[Bound.UPPER])),_ref7;},[token0,token1,ticks]);var lowerPrice=pricesAtTicks[Bound.LOWER],upperPrice=pricesAtTicks[Bound.UPPER];// liquidity range warning\nvar outOfRange=Boolean(!invalidRange&&price&&lowerPrice&&upperPrice&&(price.lessThan(lowerPrice)||price.greaterThan(upperPrice)));// amounts\nvar independentAmount=tryParseAmount(typedValue,currencies[independentField]);var dependentAmount=useMemo(function(){// we wrap the currencies just to get the price in terms of the other token\nvar wrappedIndependentAmount=independentAmount===null||independentAmount===void 0?void 0:independentAmount.wrapped;var dependentCurrency=dependentField===Field.CURRENCY_B?currencyB:currencyA;if(independentAmount&&wrappedIndependentAmount&&typeof tickLower==='number'&&typeof tickUpper==='number'&&poolForPosition){// if price is out of range or invalid range - return 0 (single deposit will be independent)\nif(outOfRange||invalidRange){return undefined;}var _position=wrappedIndependentAmount.currency.equals(poolForPosition.token0)?Position.fromAmount0({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount0:independentAmount.quotient,useFullPrecision:true// we want full precision for the theoretical position\n}):Position.fromAmount1({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount1:independentAmount.quotient});var dependentTokenAmount=wrappedIndependentAmount.currency.equals(poolForPosition.token0)?_position.amount1:_position.amount0;return dependentCurrency&&CurrencyAmount.fromRawAmount(dependentCurrency,dependentTokenAmount.quotient);}return undefined;},[independentAmount,outOfRange,dependentField,currencyB,currencyA,tickLower,tickUpper,poolForPosition,invalidRange]);var parsedAmounts=useMemo(function(){var _ref8;return _ref8={},_defineProperty(_ref8,Field.CURRENCY_A,independentField===Field.CURRENCY_A?independentAmount:dependentAmount),_defineProperty(_ref8,Field.CURRENCY_B,independentField===Field.CURRENCY_A?dependentAmount:independentAmount),_ref8;},[dependentAmount,independentAmount,independentField]);// single deposit only if price is out of range\nvar deposit0Disabled=Boolean(typeof tickUpper==='number'&&poolForPosition&&poolForPosition.tickCurrent>=tickUpper);var deposit1Disabled=Boolean(typeof tickLower==='number'&&poolForPosition&&poolForPosition.tickCurrent<=tickLower);// sorted for token order\nvar depositADisabled=invalidRange||Boolean(deposit0Disabled&&poolForPosition&&tokenA&&poolForPosition.token0.equals(tokenA)||deposit1Disabled&&poolForPosition&&tokenA&&poolForPosition.token1.equals(tokenA));var depositBDisabled=invalidRange||Boolean(deposit0Disabled&&poolForPosition&&tokenB&&poolForPosition.token0.equals(tokenB)||deposit1Disabled&&poolForPosition&&tokenB&&poolForPosition.token1.equals(tokenB));// create position entity based on users selection\nvar position=useMemo(function(){var _parsedAmounts,_parsedAmounts2;if(!poolForPosition||!tokenA||!tokenB||typeof tickLower!=='number'||typeof tickUpper!=='number'||invalidRange){return undefined;}// mark as 0 if disabled because out of range\nvar amount0=!deposit0Disabled?parsedAmounts===null||parsedAmounts===void 0?void 0:(_parsedAmounts=parsedAmounts[tokenA.equals(poolForPosition.token0)?Field.CURRENCY_A:Field.CURRENCY_B])===null||_parsedAmounts===void 0?void 0:_parsedAmounts.quotient:BIG_INT_ZERO;var amount1=!deposit1Disabled?parsedAmounts===null||parsedAmounts===void 0?void 0:(_parsedAmounts2=parsedAmounts[tokenA.equals(poolForPosition.token0)?Field.CURRENCY_B:Field.CURRENCY_A])===null||_parsedAmounts2===void 0?void 0:_parsedAmounts2.quotient:BIG_INT_ZERO;if(amount0!==undefined&&amount1!==undefined){return Position.fromAmounts({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount0:amount0,amount1:amount1,useFullPrecision:true// we want full precision for the theoretical position\n});}else{return undefined;}},[parsedAmounts,poolForPosition,tokenA,tokenB,deposit0Disabled,deposit1Disabled,invalidRange,tickLower,tickUpper]);var errorMessage;if(!account){errorMessage=/*i18n*/i18n._(\"Connect Wallet\");}if(poolState===PoolState.INVALID){var _errorMessage;errorMessage=(_errorMessage=errorMessage)!==null&&_errorMessage!==void 0?_errorMessage:/*i18n*/i18n._(\"Invalid pair\");}if(invalidPrice){var _errorMessage2;errorMessage=(_errorMessage2=errorMessage)!==null&&_errorMessage2!==void 0?_errorMessage2:/*i18n*/i18n._(\"Invalid price input\");}if(!parsedAmounts[Field.CURRENCY_A]&&!depositADisabled||!parsedAmounts[Field.CURRENCY_B]&&!depositBDisabled){var _errorMessage3;errorMessage=(_errorMessage3=errorMessage)!==null&&_errorMessage3!==void 0?_errorMessage3:/*i18n*/i18n._(\"Enter an amount\");}var currencyAAmount=parsedAmounts[Field.CURRENCY_A],currencyBAmount=parsedAmounts[Field.CURRENCY_B];if(currencyAAmount&&(currencyBalances===null||currencyBalances===void 0?void 0:(_currencyBalances$Fie=currencyBalances[Field.CURRENCY_A])===null||_currencyBalances$Fie===void 0?void 0:_currencyBalances$Fie.lessThan(currencyAAmount))){var _currencies$Field$CUR;errorMessage=/*i18n*/i18n._(\"Insufficient {0} balance\",{0:(_currencies$Field$CUR=currencies[Field.CURRENCY_A])===null||_currencies$Field$CUR===void 0?void 0:_currencies$Field$CUR.symbol});}if(currencyBAmount&&(currencyBalances===null||currencyBalances===void 0?void 0:(_currencyBalances$Fie2=currencyBalances[Field.CURRENCY_B])===null||_currencyBalances$Fie2===void 0?void 0:_currencyBalances$Fie2.lessThan(currencyBAmount))){var _currencies$Field$CUR2;errorMessage=/*i18n*/i18n._(\"Insufficient {0} balance\",{0:(_currencies$Field$CUR2=currencies[Field.CURRENCY_B])===null||_currencies$Field$CUR2===void 0?void 0:_currencies$Field$CUR2.symbol});}var invalidPool=poolState===PoolState.INVALID;return{dependentField:dependentField,currencies:currencies,pool:pool,poolState:poolState,currencyBalances:currencyBalances,parsedAmounts:parsedAmounts,ticks:ticks,price:price,pricesAtTicks:pricesAtTicks,position:position,noLiquidity:noLiquidity,errorMessage:errorMessage,invalidPool:invalidPool,invalidRange:invalidRange,outOfRange:outOfRange,depositADisabled:depositADisabled,depositBDisabled:depositBDisabled,invertPrice:invertPrice,ticksAtLimit:ticksAtLimit};}export function useRangeHopCallbacks(baseCurrency,quoteCurrency,feeAmount,tickLower,tickUpper,pool){var dispatch=useAppDispatch();var baseToken=useMemo(function(){return baseCurrency===null||baseCurrency===void 0?void 0:baseCurrency.wrapped;},[baseCurrency]);var quoteToken=useMemo(function(){return quoteCurrency===null||quoteCurrency===void 0?void 0:quoteCurrency.wrapped;},[quoteCurrency]);var getDecrementLower=useCallback(function(){if(baseToken&&quoteToken&&typeof tickLower==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickLower-TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickLower==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice=tickToPrice(baseToken,quoteToken,pool.tickCurrent-TICK_SPACINGS[feeAmount]);return _newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickLower,feeAmount,pool]);var getIncrementLower=useCallback(function(){if(baseToken&&quoteToken&&typeof tickLower==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickLower+TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickLower==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice2=tickToPrice(baseToken,quoteToken,pool.tickCurrent+TICK_SPACINGS[feeAmount]);return _newPrice2.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickLower,feeAmount,pool]);var getDecrementUpper=useCallback(function(){if(baseToken&&quoteToken&&typeof tickUpper==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickUpper-TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickUpper==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice3=tickToPrice(baseToken,quoteToken,pool.tickCurrent-TICK_SPACINGS[feeAmount]);return _newPrice3.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickUpper,feeAmount,pool]);var getIncrementUpper=useCallback(function(){if(baseToken&&quoteToken&&typeof tickUpper==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickUpper+TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickUpper==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice4=tickToPrice(baseToken,quoteToken,pool.tickCurrent+TICK_SPACINGS[feeAmount]);return _newPrice4.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickUpper,feeAmount,pool]);var getSetFullRange=useCallback(function(){dispatch(setFullRange());},[dispatch]);return{getDecrementLower:getDecrementLower,getIncrementLower:getIncrementLower,getDecrementUpper:getDecrementUpper,getIncrementUpper:getIncrementUpper,getSetFullRange:getSetFullRange};}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/state/mint/v3/hooks.ts"],"names":["BIG_INT_ZERO","getTickToPrice","JSBI","PoolState","Pool","Position","priceToClosestTick","TickMath","tickToPrice","TICK_SPACINGS","encodeSqrtRatioX96","nearestUsableTick","CurrencyAmount","Price","Rounding","useCallback","useMemo","useActiveWeb3React","tryParseAmount","useCurrencyBalances","Field","Bound","typeInput","typeStartPriceInput","typeLeftRangeInput","typeRightRangeInput","setFullRange","tryParseTick","usePool","useAppDispatch","useAppSelector","useV3MintState","state","mintV3","useV3MintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","onLeftRangeInput","onRightRangeInput","onStartPriceInput","useV3DerivedMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","account","independentField","leftRangeTypedValue","rightRangeTypedValue","startPriceTypedValue","dependentField","currencies","wrapped","tokenA","tokenB","baseToken","sortsBefore","undefined","token0","token1","balances","currencyBalances","poolState","pool","NOT_EXISTS","invertPrice","Boolean","equals","price","parsedQuoteAmount","baseAmount","currency","quotient","invert","priceOf","invalidPrice","sqrtRatioX96","numerator","denominator","invalid","greaterThanOrEqual","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","currentSqrt","getSqrtRatioAtTick","BigInt","poolForPosition","tickSpaceLimits","LOWER","MIN_TICK","UPPER","MAX_TICK","ticks","tickLower","toString","tickUpper","ticksAtLimit","invalidRange","pricesAtTicks","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","fromAmounts","errorMessage","INVALID","currencyAAmount","currencyBAmount","symbol","invalidPool","useRangeHopCallbacks","quoteCurrency","quoteToken","getDecrementLower","newPrice","toSignificant","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange"],"mappings":"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","sourcesContent":["import { t } from '@lingui/macro'\nimport { BIG_INT_ZERO } from '../../../constants/misc'\nimport { getTickToPrice } from 'utils/getTickToPrice'\nimport JSBI from 'jsbi'\nimport { PoolState } from '../../../hooks/usePools'\nimport {\n  Pool,\n  FeeAmount,\n  Position,\n  priceToClosestTick,\n  TickMath,\n  tickToPrice,\n  TICK_SPACINGS,\n  encodeSqrtRatioX96,\n  nearestUsableTick,\n} from '@uniswap/v3-sdk/dist/'\nimport { Currency, Token, CurrencyAmount, Price, Rounding } from '@uniswap/sdk-core'\nimport { useCallback, useMemo } from 'react'\nimport { useActiveWeb3React } from '../../../hooks/web3'\nimport { AppState } from '../../index'\nimport { tryParseAmount } from '../../swap/hooks'\nimport { useCurrencyBalances } from '../../wallet/hooks'\nimport {\n  Field,\n  Bound,\n  typeInput,\n  typeStartPriceInput,\n  typeLeftRangeInput,\n  typeRightRangeInput,\n  setFullRange,\n} from './actions'\nimport { tryParseTick } from './utils'\nimport { usePool } from 'hooks/usePools'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\n\nexport function useV3MintState(): AppState['mintV3'] {\n  return useAppSelector((state) => state.mintV3)\n}\n\nexport function useV3MintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n  onLeftRangeInput: (typedValue: string) => void\n  onRightRangeInput: (typedValue: string) => void\n  onStartPriceInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onLeftRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeLeftRangeInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onRightRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeRightRangeInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onStartPriceInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeStartPriceInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  }\n}\n\nexport function useV3DerivedMintInfo(\n  currencyA?: Currency,\n  currencyB?: Currency,\n  feeAmount?: FeeAmount,\n  baseCurrency?: Currency,\n  // override for existing position\n  existingPosition?: Position\n): {\n  pool?: Pool | null\n  poolState: PoolState\n  ticks: { [bound in Bound]?: number | undefined }\n  price?: Price<Token, Token>\n  pricesAtTicks: {\n    [bound in Bound]?: Price<Token, Token> | undefined\n  }\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  dependentField: Field\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  position: Position | undefined\n  noLiquidity?: boolean\n  errorMessage?: string\n  invalidPool: boolean\n  outOfRange: boolean\n  invalidRange: boolean\n  depositADisabled: boolean\n  depositBDisabled: boolean\n  invertPrice: boolean\n  ticksAtLimit: { [bound in Bound]?: boolean | undefined }\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, typedValue, leftRangeTypedValue, rightRangeTypedValue, startPriceTypedValue } =\n    useV3MintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // currencies\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA,\n      [Field.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency]\n  )\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB]\n  )\n\n  // balances\n  const balances = useCurrencyBalances(account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B],\n  ])\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount)\n  const noLiquidity = poolState === PoolState.NOT_EXISTS\n\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0))\n\n  // always returns the price with 0 as base token\n  const price: Price<Token, Token> | undefined = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPriceTypedValue, invertPrice ? token0 : token1)\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount('1', invertPrice ? token1 : token0)\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient\n              )\n            : undefined\n        return (invertPrice ? price?.invert() : price) ?? undefined\n      }\n      return undefined\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool])\n\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined\n    const invalid =\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      )\n    return invalid\n  }, [price])\n\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price)\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick)\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, [])\n    } else {\n      return undefined\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB])\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition: Pool | undefined = pool ?? mockPool\n\n  // lower and upper limits in the tick space for `feeAmount`\n  const tickSpaceLimits: {\n    [bound in Bound]: number | undefined\n  } = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount]\n  )\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks: {\n    [key: string]: number | undefined\n  } = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === 'number'\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (!invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === 'number'\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    }\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ])\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {}\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount]\n  )\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper)\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    }\n  }, [token0, token1, ticks])\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks\n\n  // liquidity range warning\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField]\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === 'number' &&\n      typeof tickUpper === 'number' &&\n      poolForPosition\n    ) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined\n      }\n\n      const position: Position | undefined = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true, // we want full precision for the theoretical position\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          })\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n    }\n\n    return undefined\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper\n  )\n  const deposit1Disabled = Boolean(\n    typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower\n  )\n\n  // sorted for token order\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA))\n    )\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB))\n    )\n\n  // create position entity based on users selection\n  const position: Position | undefined = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== 'number' ||\n      typeof tickUpper !== 'number' ||\n      invalidRange\n    ) {\n      return undefined\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      })\n    } else {\n      return undefined\n    }\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ])\n\n  let errorMessage: string | undefined\n  if (!account) {\n    errorMessage = t`Connect Wallet`\n  }\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? t`Invalid pair`\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? t`Invalid price input`\n  }\n\n  if (\n    (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? t`Enter an amount`\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = t`Insufficient ${currencies[Field.CURRENCY_A]?.symbol} balance`\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = t`Insufficient ${currencies[Field.CURRENCY_B]?.symbol} balance`\n  }\n\n  const invalidPool = poolState === PoolState.INVALID\n\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit,\n  }\n}\n\nexport function useRangeHopCallbacks(\n  baseCurrency: Currency | undefined,\n  quoteCurrency: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool?: Pool | undefined | null\n) {\n  const dispatch = useAppDispatch()\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency])\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency])\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange())\n  }, [dispatch])\n\n  return { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper, getSetFullRange }\n}\n"]},"metadata":{},"sourceType":"module"}