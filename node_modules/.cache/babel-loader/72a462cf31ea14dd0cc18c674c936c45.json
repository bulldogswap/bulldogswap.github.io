{"ast":null,"code":"import _slicedToArray from\"/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{priceToClosestTick,nearestUsableTick,TICK_SPACINGS,encodeSqrtRatioX96,TickMath}from'@uniswap/v3-sdk/dist/';import{Price}from'@uniswap/sdk-core';import JSBI from'jsbi';export function tryParsePrice(baseToken,quoteToken,value){var _fraction$length;if(!baseToken||!quoteToken||!value){return undefined;}if(!value.match(/^\\d*\\.?\\d+$/)){return undefined;}var _value$split=value.split('.'),_value$split2=_slicedToArray(_value$split,2),whole=_value$split2[0],fraction=_value$split2[1];var decimals=(_fraction$length=fraction===null||fraction===void 0?void 0:fraction.length)!==null&&_fraction$length!==void 0?_fraction$length:0;var withoutDecimals=JSBI.BigInt((whole!==null&&whole!==void 0?whole:'')+(fraction!==null&&fraction!==void 0?fraction:''));return new Price(baseToken,quoteToken,JSBI.multiply(JSBI.BigInt(Math.pow(10,decimals)),JSBI.BigInt(Math.pow(10,baseToken.decimals))),JSBI.multiply(withoutDecimals,JSBI.BigInt(Math.pow(10,quoteToken.decimals))));}export function tryParseTick(baseToken,quoteToken,feeAmount,value){if(!baseToken||!quoteToken||!feeAmount||!value){return undefined;}var price=tryParsePrice(baseToken,quoteToken,value);if(!price){return undefined;}var tick;// check price is within min/max bounds, if outside return min/max\nvar sqrtRatioX96=encodeSqrtRatioX96(price.numerator,price.denominator);if(JSBI.greaterThanOrEqual(sqrtRatioX96,TickMath.MAX_SQRT_RATIO)){tick=TickMath.MAX_TICK;}else if(JSBI.lessThanOrEqual(sqrtRatioX96,TickMath.MIN_SQRT_RATIO)){tick=TickMath.MIN_TICK;}else{// this function is agnostic to the base, will always return the correct tick\ntick=priceToClosestTick(price);}return nearestUsableTick(tick,TICK_SPACINGS[feeAmount]);}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/state/mint/v3/utils.ts"],"names":["priceToClosestTick","nearestUsableTick","TICK_SPACINGS","encodeSqrtRatioX96","TickMath","Price","JSBI","tryParsePrice","baseToken","quoteToken","value","undefined","match","split","whole","fraction","decimals","length","withoutDecimals","BigInt","multiply","tryParseTick","feeAmount","price","tick","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MAX_SQRT_RATIO","MAX_TICK","lessThanOrEqual","MIN_SQRT_RATIO","MIN_TICK"],"mappings":"wLAAA,OACEA,kBADF,CAEEC,iBAFF,CAIEC,aAJF,CAKEC,kBALF,CAMEC,QANF,KAOO,uBAPP,CAQA,OAASC,KAAT,KAA6B,mBAA7B,CACA,MAAOC,CAAAA,IAAP,KAAiB,MAAjB,CAEA,MAAO,SAASC,CAAAA,aAAT,CAAuBC,SAAvB,CAA0CC,UAA1C,CAA8DC,KAA9D,CAA8E,sBACnF,GAAI,CAACF,SAAD,EAAc,CAACC,UAAf,EAA6B,CAACC,KAAlC,CAAyC,CACvC,MAAOC,CAAAA,SAAP,CACD,CAED,GAAI,CAACD,KAAK,CAACE,KAAN,CAAY,aAAZ,CAAL,CAAiC,CAC/B,MAAOD,CAAAA,SAAP,CACD,CAED,iBAA0BD,KAAK,CAACG,KAAN,CAAY,GAAZ,CAA1B,8CAAOC,KAAP,kBAAcC,QAAd,kBAEA,GAAMC,CAAAA,QAAQ,mBAAGD,QAAH,SAAGA,QAAH,iBAAGA,QAAQ,CAAEE,MAAb,qDAAuB,CAArC,CACA,GAAMC,CAAAA,eAAe,CAAGZ,IAAI,CAACa,MAAL,CAAY,CAACL,KAAD,SAACA,KAAD,UAACA,KAAD,CAAU,EAAV,GAAiBC,QAAjB,SAAiBA,QAAjB,UAAiBA,QAAjB,CAA6B,EAA7B,CAAZ,CAAxB,CAEA,MAAO,IAAIV,CAAAA,KAAJ,CACLG,SADK,CAELC,UAFK,CAGLH,IAAI,CAACc,QAAL,CAAcd,IAAI,CAACa,MAAL,UAAY,EAAZ,CAAkBH,QAAlB,EAAd,CAA2CV,IAAI,CAACa,MAAL,UAAY,EAAZ,CAAkBX,SAAS,CAACQ,QAA5B,EAA3C,CAHK,CAILV,IAAI,CAACc,QAAL,CAAcF,eAAd,CAA+BZ,IAAI,CAACa,MAAL,UAAY,EAAZ,CAAkBV,UAAU,CAACO,QAA7B,EAA/B,CAJK,CAAP,CAMD,CAED,MAAO,SAASK,CAAAA,YAAT,CACLb,SADK,CAELC,UAFK,CAGLa,SAHK,CAILZ,KAJK,CAKe,CACpB,GAAI,CAACF,SAAD,EAAc,CAACC,UAAf,EAA6B,CAACa,SAA9B,EAA2C,CAACZ,KAAhD,CAAuD,CACrD,MAAOC,CAAAA,SAAP,CACD,CAED,GAAMY,CAAAA,KAAK,CAAGhB,aAAa,CAACC,SAAD,CAAYC,UAAZ,CAAwBC,KAAxB,CAA3B,CAEA,GAAI,CAACa,KAAL,CAAY,CACV,MAAOZ,CAAAA,SAAP,CACD,CAED,GAAIa,CAAAA,IAAJ,CAEA;AACA,GAAMC,CAAAA,YAAY,CAAGtB,kBAAkB,CAACoB,KAAK,CAACG,SAAP,CAAkBH,KAAK,CAACI,WAAxB,CAAvC,CAEA,GAAIrB,IAAI,CAACsB,kBAAL,CAAwBH,YAAxB,CAAsCrB,QAAQ,CAACyB,cAA/C,CAAJ,CAAoE,CAClEL,IAAI,CAAGpB,QAAQ,CAAC0B,QAAhB,CACD,CAFD,IAEO,IAAIxB,IAAI,CAACyB,eAAL,CAAqBN,YAArB,CAAmCrB,QAAQ,CAAC4B,cAA5C,CAAJ,CAAiE,CACtER,IAAI,CAAGpB,QAAQ,CAAC6B,QAAhB,CACD,CAFM,IAEA,CACL;AACAT,IAAI,CAAGxB,kBAAkB,CAACuB,KAAD,CAAzB,CACD,CAED,MAAOtB,CAAAA,iBAAiB,CAACuB,IAAD,CAAOtB,aAAa,CAACoB,SAAD,CAApB,CAAxB,CACD","sourcesContent":["import {\n  priceToClosestTick,\n  nearestUsableTick,\n  FeeAmount,\n  TICK_SPACINGS,\n  encodeSqrtRatioX96,\n  TickMath,\n} from '@uniswap/v3-sdk/dist/'\nimport { Price, Token } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\n\nexport function tryParsePrice(baseToken?: Token, quoteToken?: Token, value?: string) {\n  if (!baseToken || !quoteToken || !value) {\n    return undefined\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined\n  }\n\n  const [whole, fraction] = value.split('.')\n\n  const decimals = fraction?.length ?? 0\n  const withoutDecimals = JSBI.BigInt((whole ?? '') + (fraction ?? ''))\n\n  return new Price(\n    baseToken,\n    quoteToken,\n    JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)),\n    JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals))\n  )\n}\n\nexport function tryParseTick(\n  baseToken?: Token,\n  quoteToken?: Token,\n  feeAmount?: FeeAmount,\n  value?: string\n): number | undefined {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value)\n\n  if (!price) {\n    return undefined\n  }\n\n  let tick: number\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator)\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price)\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount])\n}\n"]},"metadata":{},"sourceType":"module"}