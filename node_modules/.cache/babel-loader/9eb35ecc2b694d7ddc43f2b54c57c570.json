{"ast":null,"code":"var CONSERVATIVE_BLOCK_GAS_LIMIT=10000000;// conservative, hard-coded estimate of the current block gas limit\nexport var DEFAULT_GAS_REQUIRED=200000;// the default value for calls that don't specify gasRequired\n// chunks array into chunks\n// evenly distributes items among the chunks\nexport default function chunkArray(items){var gasLimit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:CONSERVATIVE_BLOCK_GAS_LIMIT*10;var chunks=[];var currentChunk=[];var currentChunkCumulativeGas=0;for(var i=0;i<items.length;i++){var _gasRequired;var item=items[i];// calculate the gas required by the current item\nvar gasRequired=(_gasRequired=item===null||item===void 0?void 0:item.gasRequired)!==null&&_gasRequired!==void 0?_gasRequired:DEFAULT_GAS_REQUIRED;// if the current chunk is empty, or the current item wouldn't push it over the gas limit,\n// append the current item and increment the cumulative gas\nif(currentChunk.length===0||currentChunkCumulativeGas+gasRequired<gasLimit){currentChunk.push(item);currentChunkCumulativeGas+=gasRequired;}else{// otherwise, push the current chunk and create a new chunk\nchunks.push(currentChunk);currentChunk=[item];currentChunkCumulativeGas=gasRequired;}}if(currentChunk.length>0)chunks.push(currentChunk);return chunks;}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/utils/chunkArray.ts"],"names":["CONSERVATIVE_BLOCK_GAS_LIMIT","DEFAULT_GAS_REQUIRED","chunkArray","items","gasLimit","chunks","currentChunk","currentChunkCumulativeGas","i","length","item","gasRequired","push"],"mappings":"AAAA,GAAMA,CAAAA,4BAA4B,CAAG,QAArC,CAAgD;AAChD,MAAO,IAAMC,CAAAA,oBAAoB,CAAG,MAA7B,CAAqC;AAE5C;AACA;AACA,cAAe,SAASC,CAAAA,UAAT,CAAuBC,KAAvB,CAAwF,IAArDC,CAAAA,QAAqD,2DAA1CJ,4BAA4B,CAAG,EAAW,CACrG,GAAMK,CAAAA,MAAa,CAAG,EAAtB,CACA,GAAIC,CAAAA,YAAiB,CAAG,EAAxB,CACA,GAAIC,CAAAA,yBAAyB,CAAG,CAAhC,CAEA,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,KAAK,CAACM,MAA1B,CAAkCD,CAAC,EAAnC,CAAuC,kBACrC,GAAME,CAAAA,IAAI,CAAGP,KAAK,CAACK,CAAD,CAAlB,CAEA;AACA,GAAMG,CAAAA,WAAW,eAAID,IAAJ,SAAIA,IAAJ,iBAAIA,IAAD,CAAoCC,WAAvC,6CAAsDV,oBAAvE,CAEA;AACA;AACA,GAAIK,YAAY,CAACG,MAAb,GAAwB,CAAxB,EAA6BF,yBAAyB,CAAGI,WAA5B,CAA0CP,QAA3E,CAAqF,CACnFE,YAAY,CAACM,IAAb,CAAkBF,IAAlB,EACAH,yBAAyB,EAAII,WAA7B,CACD,CAHD,IAGO,CACL;AACAN,MAAM,CAACO,IAAP,CAAYN,YAAZ,EACAA,YAAY,CAAG,CAACI,IAAD,CAAf,CACAH,yBAAyB,CAAGI,WAA5B,CACD,CACF,CACD,GAAIL,YAAY,CAACG,MAAb,CAAsB,CAA1B,CAA6BJ,MAAM,CAACO,IAAP,CAAYN,YAAZ,EAE7B,MAAOD,CAAAA,MAAP,CACD","sourcesContent":["const CONSERVATIVE_BLOCK_GAS_LIMIT = 10_000_000 // conservative, hard-coded estimate of the current block gas limit\nexport const DEFAULT_GAS_REQUIRED = 200_000 // the default value for calls that don't specify gasRequired\n\n// chunks array into chunks\n// evenly distributes items among the chunks\nexport default function chunkArray<T>(items: T[], gasLimit = CONSERVATIVE_BLOCK_GAS_LIMIT * 10): T[][] {\n  const chunks: T[][] = []\n  let currentChunk: T[] = []\n  let currentChunkCumulativeGas = 0\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i]\n\n    // calculate the gas required by the current item\n    const gasRequired = (item as { gasRequired?: number })?.gasRequired ?? DEFAULT_GAS_REQUIRED\n\n    // if the current chunk is empty, or the current item wouldn't push it over the gas limit,\n    // append the current item and increment the cumulative gas\n    if (currentChunk.length === 0 || currentChunkCumulativeGas + gasRequired < gasLimit) {\n      currentChunk.push(item)\n      currentChunkCumulativeGas += gasRequired\n    } else {\n      // otherwise, push the current chunk and create a new chunk\n      chunks.push(currentChunk)\n      currentChunk = [item]\n      currentChunkCumulativeGas = gasRequired\n    }\n  }\n  if (currentChunk.length > 0) chunks.push(currentChunk)\n\n  return chunks\n}\n"]},"metadata":{},"sourceType":"module"}