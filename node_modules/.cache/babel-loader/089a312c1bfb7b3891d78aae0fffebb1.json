{"ast":null,"code":"import{useMemo}from'react';import{isAddress}from'../../utils';var alwaysTrue=function alwaysTrue(){return true;};/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */export function createTokenFilterFunction(search){var searchingAddress=isAddress(search);if(searchingAddress){var lower=searchingAddress.toLowerCase();return function(t){return'isToken'in t?searchingAddress===t.address:lower===t.address.toLowerCase();};}var lowerSearchParts=search.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});if(lowerSearchParts.length===0)return alwaysTrue;var matchesSearch=function matchesSearch(s){var sParts=s.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});return lowerSearchParts.every(function(p){return p.length===0||sParts.some(function(sp){return sp.startsWith(p)||sp.endsWith(p);});});};return function(_ref){var name=_ref.name,symbol=_ref.symbol;return Boolean(symbol&&matchesSearch(symbol)||name&&matchesSearch(name));};}export function filterTokens(tokens,search){return tokens.filter(createTokenFilterFunction(search));}export function useSortedTokensByQuery(tokens,searchQuery){return useMemo(function(){if(!tokens){return[];}var symbolMatch=searchQuery.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});if(symbolMatch.length>1){return tokens;}var exactMatches=[];var symbolSubtrings=[];var rest=[];// sort tokens by exact match -> subtring on symbol match -> rest\ntokens.map(function(token){var _token$symbol,_token$symbol2;if(((_token$symbol=token.symbol)===null||_token$symbol===void 0?void 0:_token$symbol.toLowerCase())===symbolMatch[0]){return exactMatches.push(token);}else if((_token$symbol2=token.symbol)===null||_token$symbol2===void 0?void 0:_token$symbol2.toLowerCase().startsWith(searchQuery.toLowerCase().trim())){return symbolSubtrings.push(token);}else{return rest.push(token);}});return[].concat(exactMatches,symbolSubtrings,rest);},[tokens,searchQuery]);}","map":{"version":3,"sources":["/Users/nakanoteppei/Documents/Jupiter/Codes/bulldogswap.github.io/src/components/SearchModal/filtering.ts"],"names":["useMemo","isAddress","alwaysTrue","createTokenFilterFunction","search","searchingAddress","lower","toLowerCase","t","address","lowerSearchParts","split","filter","s","length","matchesSearch","sParts","every","p","some","sp","startsWith","endsWith","name","symbol","Boolean","filterTokens","tokens","useSortedTokensByQuery","searchQuery","symbolMatch","exactMatches","symbolSubtrings","rest","map","token","push","trim"],"mappings":"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","sourcesContent":["import { TokenInfo } from '@uniswap/token-lists'\nimport { useMemo } from 'react'\nimport { isAddress } from '../../utils'\nimport { Token } from '@uniswap/sdk-core'\n\nconst alwaysTrue = () => true\n\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\nexport function createTokenFilterFunction<T extends Token | TokenInfo>(search: string): (tokens: T) => boolean {\n  const searchingAddress = isAddress(search)\n\n  if (searchingAddress) {\n    const lower = searchingAddress.toLowerCase()\n    return (t: T) => ('isToken' in t ? searchingAddress === t.address : lower === t.address.toLowerCase())\n  }\n\n  const lowerSearchParts = search\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0)\n\n  if (lowerSearchParts.length === 0) return alwaysTrue\n\n  const matchesSearch = (s: string): boolean => {\n    const sParts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)))\n  }\n\n  return ({ name, symbol }: T): boolean => Boolean((symbol && matchesSearch(symbol)) || (name && matchesSearch(name)))\n}\n\nexport function filterTokens<T extends Token | TokenInfo>(tokens: T[], search: string): T[] {\n  return tokens.filter(createTokenFilterFunction(search))\n}\n\nexport function useSortedTokensByQuery(tokens: Token[] | undefined, searchQuery: string): Token[] {\n  return useMemo(() => {\n    if (!tokens) {\n      return []\n    }\n\n    const symbolMatch = searchQuery\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    if (symbolMatch.length > 1) {\n      return tokens\n    }\n\n    const exactMatches: Token[] = []\n    const symbolSubtrings: Token[] = []\n    const rest: Token[] = []\n\n    // sort tokens by exact match -> subtring on symbol match -> rest\n    tokens.map((token) => {\n      if (token.symbol?.toLowerCase() === symbolMatch[0]) {\n        return exactMatches.push(token)\n      } else if (token.symbol?.toLowerCase().startsWith(searchQuery.toLowerCase().trim())) {\n        return symbolSubtrings.push(token)\n      } else {\n        return rest.push(token)\n      }\n    })\n\n    return [...exactMatches, ...symbolSubtrings, ...rest]\n  }, [tokens, searchQuery])\n}\n"]},"metadata":{},"sourceType":"module"}